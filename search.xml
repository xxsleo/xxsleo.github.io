<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基本命令(2)-Linux管理</title>
      <link href="/2022/01/27/JavaWeb/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20(2)-Linux%E7%AE%A1%E7%90%86/"/>
      <url>/2022/01/27/JavaWeb/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20(2)-Linux%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><strong>语法：</strong></p><ul><li>touch [参数选项] 文件名        如果文件不存在就创建文件</li><li><pre><code>                     如果存在就修改时间属性</code></pre></li></ul><p><strong>参数说明</strong>：</p><ul><li>a 改变档案的读取时间记录。</li><li>m 改变档案的修改时间记录。</li><li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li><li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li><li>r 使用参考档的时间记录，与 –file 的效果一样。</li><li>d 设定时间与日期，可以使用各种不同的格式。</li><li>t 设定档案的时间记录，格式与 date 指令相同。</li><li>–no-create 不会建立新档案。</li><li>–help 列出指令格式。</li><li>–version 列出版本讯息。</li></ul><p><strong>常用命令</strong></p><ul><li>touch a.txt        不存在就创建，存在就修改时间属性</li><li>touch a{1..10}.txt    批量创建空文件</li><li>stat a.txt          查看文件的详细信息</li></ul><h3 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h3><h4 id="vi-vim介绍"><a href="#vi-vim介绍" class="headerlink" title="vi/vim介绍"></a>vi/vim介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作</span><br></pre></td></tr></table></figure><p><strong>1、vi介绍</strong></p><p>vi是 <code>visual interface</code>的简称, 是linux中<strong>最经典</strong>的文本编辑器。</p><ul><li>vi的特点<ul><li>只能是编辑 <strong>文本内容</strong>, 不能对 字体 段落进行排版</li><li><strong>不支持鼠标操作</strong></li><li><strong>没有菜单</strong></li><li><strong>只有命令</strong></li></ul></li><li>vi编辑器在 <strong>系统管理 服务器管理</strong> 编辑文件时, <strong>其功能永远不是图形界面的编辑器能比拟的</strong></li></ul><p><strong>2、vim介绍</strong></p><ul><li>左下角会有一个冒号出现，此时可以敲入命令并执行。</li><li>三种模式</li></ul><blockquote><p>上面的三种模式简单总结下就是：</p><p>1、vim  开始进入时是命令模式</p><p>2、按下I的时候会进入编辑模式</p><p>3、按下ESC然后在按下：的时候是末行模式</p></blockquote><h3 id="打开和新建文件"><a href="#打开和新建文件" class="headerlink" title="打开和新建文件"></a>打开和新建文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。</span><br></pre></td></tr></table></figure><p><strong>使用者权限：当前文件的权限用户</strong></p><ul><li>在终端中输入vim在后面跟上 文件名 即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim txtfile.txt</span><br></pre></td></tr></table></figure><ul><li>如果文件已经存在, 会直接打开该文件</li><li>如果文件不存在, 保存且退出时 就会新建一个文件</li></ul><blockquote><p>注意</p><p>我们通过下面的三种模式切换详细阐述vim的用法</p></blockquote><h3 id="三种模式切换"><a href="#三种模式切换" class="headerlink" title="三种模式切换"></a>三种模式切换</h3><p><strong>1、进入命令模式</strong></p><p>上接上面的例子，我们执行下面的命令其实就是进入了命令模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下图</p><p><img src="assets/1576655123201.png" alt="1576655123201"></p><p><strong>2、进入编辑模式</strong></p><p>上接上面的例子，按i进入插入模式</p><ul><li>在 vi 中除了常用 <code>i</code> 进入<strong>编辑模式</strong> 外, 还提供了一下命令同样可以进入编辑模式</li></ul><table><thead><tr><th>命令</th><th>英文</th><th>功能</th><th>常用</th></tr></thead><tbody><tr><td>i</td><td>insert</td><td>在当前字符前插入文本</td><td>常用</td></tr><tr><td>I</td><td>insert</td><td>在行首插入文本</td><td>较常用</td></tr><tr><td>a</td><td>append</td><td>在当前字符后添加文本</td><td></td></tr><tr><td>A</td><td>append</td><td>在行末添加文本</td><td>较常用</td></tr><tr><td>o</td><td></td><td>在当前行后面插入一空行</td><td>常用</td></tr><tr><td>O</td><td></td><td>在当前行前面插入一空行</td><td>常用</td></tr></tbody></table><p>上图可以表现为以下形式，如下图</p><p><img src="assets/1576663442969.png" alt="1576663442969"></p><p>执行效果如下图</p><p><img src="assets/1576655181144.png" alt="1576655181144"></p><p>由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式</p><p>我们在里面插入数据，如下图</p><p>因为我们是一个空文件，所以使用【I】或者【i】都可以</p><p>如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本</p><p><img src="assets/1576655270283.png" alt="1576655270283"></p><p><strong>3、进入末行模式</strong></p><p>编辑模式不能保存文件<br>必须先推到命令模式<br>先按Esc键退出到命令模式<br>然后按小写的**:wq 正常保存退出**</p><p>进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图</p><p><img src="assets/1576655879564.png" alt="1576655879564"></p><p>然后按小写的**:wq 正常保存退出**</p><p><img src="assets/1576655592207.png" alt="1576655592207"></p><p>退出后显示【已写入】</p><p><strong>以下为其他的退出模式：</strong></p><p>:q            当vim进入文件没有对文件内容做任何操作可以按”q”退出</p><p>:q!           当vim进入文件对文件内容有操作但不想保存退出</p><p>:wq          正常保存退出</p><p>:wq!         强行保存退出，只针对与root用户或文件所有人生</p><blockquote><p>总结</p><p>三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤</p><p>那么接下来，我们学习下一个命令</p><p>查看刚才新创建的文件</p></blockquote><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看</span><br></pre></td></tr></table></figure><p>以下5个为文件查看命令，<strong>我们只讲4个常用的命令，head不在赘述</strong></p><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看小文件内容</td></tr><tr><td>02</td><td>less -N 文件名</td><td>less</td><td><strong>分频</strong> 显示大文件内容</td></tr><tr><td>03</td><td>head -n 文件名</td><td></td><td>查看文件的<strong>前一</strong>部分</td></tr><tr><td>04</td><td>tail -n 文件名</td><td></td><td>查看文件的<strong>最后</strong>部分</td></tr><tr><td>05</td><td>grep 关键字 文件名</td><td>grep</td><td>根据<strong>关键词</strong>, 搜索文本文件内容</td></tr></tbody></table><blockquote><p>总结：</p><p>以上5个命令都可以查询文件的内容，他们的功能如下</p><p>通过 <code>cat</code> 会一次显示所有的内容, 适合 <strong>查看内容较少</strong> 的文本文件</p><p><code>less</code> 命令适合查看 <strong>内容较多</strong> 的文本文件</p><p>通过 <code>head</code> 命令查看文档的前几行内容</p><p>通过 <code>tail -10f 文件</code> 命令 查看文档(日志)的后几行内容</p><p>通过 <code>grep</code> 命令 搜索存在 <strong>关键字</strong> 的行</p></blockquote><h4 id="1-cat命令"><a href="#1-cat命令" class="headerlink" title="1) cat命令"></a><strong>1) cat命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的</span><br><span class="line">txt---打开--查看</span><br></pre></td></tr></table></figure><p>cat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt</p><p><strong>使用者权限：当前文件的权限用户</strong></p><p><strong>语法格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure><p><strong>查看文件名为txtfile.txt的内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下图</p><p><img src="assets/1576657358085.png" alt="1576657358085"></p><p><strong>查看文件名为txtfile.txt的内容（加入行号）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下图</p><p><img src="assets/1576657409815.png" alt="1576657409815"></p><h4 id="2-grep命令"><a href="#2-grep命令" class="headerlink" title="2) grep命令"></a>2) grep命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找</span><br><span class="line">grep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程</span><br></pre></td></tr></table></figure><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p><p>grep 命令用于查找文件里符合条件的字符串，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>使用者权限：当前文件的权限用户</strong></p><p>我们还是使用上面的txtfile.txt文件，如下图</p><p><img src="assets/1576664862829.png" alt="1576664862829"></p><blockquote><p>为了测试效果，我们新增了其他数据</p><p>增加过程不在赘述</p></blockquote><p>1、搜索 <strong>存在关键字【eeee】</strong> 的行的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep eeee txtfile.txt </span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576664910366.png" alt="1576664910366"></p><p>2、搜索 <strong>存在关键字【eeee】</strong> 的行 且 <strong>显示行号</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n eeee txtfile.txt </span><br></pre></td></tr></table></figure><p><img src="assets/1576665113269.png" alt="1576665113269"></p><p>3、<strong>忽略大小写</strong> 搜索 <strong>存在关键字</strong> 的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i EEEE txtfile.txt </span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576666861596.png" alt="1576666861596"></p><p>4、搜索 <strong>不存在关键字</strong> 的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v 中国 txtfile.txt </span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576666928266.png" alt="1576666928266"></p><p><strong>5、查找指定的进程信息（包含grep进程）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep  sshd</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577095621215.png" alt="1577095621215"></p><blockquote><p>说明</p><p>除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程</p></blockquote><p><strong>6、查找指定的进程信息（不包含grep进程）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep sshd | grep -v &quot;grep&quot;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577095998308.png" alt="1577095998308"></p><p><strong>7、查找进程个数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep -c sshd</span><br></pre></td></tr></table></figure><p> 执行效果如下</p><p><img src="assets/1577096070670.png" alt="1577096070670"></p><p>由上图可知sshd的进程个数为4（包含grep进程本身）</p><h4 id="3-tail命令"><a href="#3-tail命令" class="headerlink" title="3) tail命令"></a>3) tail命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现</span><br></pre></td></tr></table></figure><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件。</p><p><strong>tail -f filename</strong> 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p><p><strong>使用者权限：当前文件的权限用户</strong></p><p><strong>命令格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [参数] [文件]  </span><br></pre></td></tr></table></figure><p><strong>1、要显示 txtfile.txt  文件的最后 3 行，请输入以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -3 txtfile.txt </span><br></pre></td></tr></table></figure><p>原始文件内容如下</p><p><img src="assets/1576667678964.png" alt="1576667678964"></p><p>最后3行内容如下</p><p><img src="assets/1576667701796.png" alt="1576667701796"></p><p><strong>2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><p><img src="assets/1576667811261.png" alt="1576667811261"></p><p>此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。</p><p>如果要显示最后4行，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -4f txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576719306123.png" alt="1576719306123"></p><p><strong>3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail  -n +2  txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576719057889.png" alt="1576719057889"></p><p><strong>4、显示文件 txtfile.txt的最后 10 个字符:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c 45 txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576719098586.png" alt="1576719098586"></p><blockquote><p>总结</p><p>在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行</p><p>使用tail -nf txtfile.txt</p><p>通常都是在查看日志信息（报错调试时使用）</p></blockquote><h4 id="4）less命令"><a href="#4）less命令" class="headerlink" title="4）less命令"></a>4）less命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容,  每次只显示一页内容，有点类似我们做分页查询</span><br></pre></td></tr></table></figure><p>less用于查看文件，但是less 在查看之前不会加载整个文件。</p><p><strong>使用者权限：当前文件的权限用户</strong></p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件 </span><br></pre></td></tr></table></figure><p>1、查看txtfile.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less txtfile.txt</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576720622842.png" alt="1576720622842"></p><p>2、查看命令历史使用记录并通过less分页显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[itcast@localhost ~]$  history | less</span><br><span class="line">    1  ifconfig</span><br><span class="line">    2  reboot</span><br><span class="line">    3  ifconfig</span><br><span class="line">    4  reboot</span><br><span class="line">    5  ifconfig</span><br><span class="line">    6  su root</span><br><span class="line">    7  ifconfig</span><br><span class="line">    8  ping  www.baidu.com</span><br><span class="line">    9  \</span><br><span class="line">   10  ifconfig</span><br><span class="line">   11  date</span><br><span class="line">   12  hwclock --systohc</span><br><span class="line">   13  su root</span><br><span class="line">   </span><br><span class="line">   ......略</span><br></pre></td></tr></table></figure><p>我们输入【j】可以前进行</p><p>​        输入【k】可以后退行</p><p>​        输入【G】可以 移动到最后一行</p><p>​        输入【g】可以移动到第一行</p><p>​        输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页)</p><p>​        输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页)</p><p><strong>其他命令</strong></p><p>1.全屏导航</p><ul><li>ctrl + F - 向前移动一屏</li><li>ctrl + B - 向后移动一屏</li><li>ctrl + D - 向前移动半屏</li><li>ctrl + U - 向后移动半屏</li></ul><p>2.单行导航</p><ul><li>j - 向前移动一行</li><li>k - 向后移动一行</li></ul><p>3.其它导航</p><ul><li>G - 移动到最后一行</li><li>g - 移动到第一行</li><li>q / ZZ - 退出 less 命令</li></ul><h3 id="vim定位行"><a href="#vim定位行" class="headerlink" title="vim定位行"></a>vim定位行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况</span><br><span class="line">例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置</span><br><span class="line">这个时候,可以使用以下命令打开文件</span><br></pre></td></tr></table></figure><p>由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim txtfile.txt +6</span><br></pre></td></tr></table></figure><p>执行效果如下图</p><p><img src="assets/1576659165723.png" alt="1576659165723"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h3><ul><li>如果 vim异常退出, 在磁盘上可能会保存有 交换文件</li><li>下次再使用 vim 编辑文件时, 会看到以下屏幕信息,</li></ul><p><img src="assets/1576658330514.png" alt="1576658330514"></p><p>解决方案：</p><p>将后缀名为.swp的文件删除即可恢复</p><p><img src="assets/1576658480811.png" alt="1576658480811"></p><p>再次编辑文件不在出现提示警告！</p><h3 id="操作扩展"><a href="#操作扩展" class="headerlink" title="操作扩展"></a>操作扩展</h3><p>要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标<br>编辑操作命令 能够和移动命令一起使用</p><p><strong>1) 上 下 左 右</strong></p><p><img src="assets/1558278451153.png" alt="1558278451153"></p><table><thead><tr><th>命令</th><th>功能</th><th>手指</th></tr></thead><tbody><tr><td>h</td><td>向左</td><td>食指</td></tr><tr><td>j</td><td>向下</td><td>食指</td></tr><tr><td>k</td><td>向上</td><td>中指</td></tr><tr><td>l</td><td>向右</td><td>无名指</td></tr></tbody></table><p>也可以使用键盘上的上下左右箭头，这个更有方向感。</p><p><strong>2) 行内移动</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>w</td><td>word</td><td>向后移动一个单词</td></tr><tr><td>b</td><td>back</td><td>向前移动一个单词</td></tr><tr><td>0</td><td></td><td>行首</td></tr><tr><td>^</td><td></td><td>行首, 第一个不是空白字符的位置</td></tr><tr><td>$</td><td></td><td>行尾</td></tr></tbody></table><p><strong>3) 行数移动</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>gg</td><td>go</td><td>文件顶部</td></tr><tr><td>G</td><td>go</td><td>文件末尾</td></tr><tr><td>数字gg</td><td>go</td><td>移动到 数字 对应行数</td></tr><tr><td>数字G</td><td>go</td><td>移动到 数字 对应行数</td></tr><tr><td>: 数字</td><td></td><td>移动到数字对应的 行数</td></tr></tbody></table><p><strong>4) 屏幕移动</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + b</td><td>back</td><td>向上翻页</td></tr><tr><td>Ctrl + f</td><td>forward</td><td>向下翻页</td></tr><tr><td>H</td><td>Head</td><td>屏幕顶部</td></tr><tr><td>M</td><td>Middle</td><td>屏幕中间</td></tr><tr><td>L</td><td>Low</td><td>屏幕底部</td></tr></tbody></table><p><strong>5) 选中文本(可视模式)</strong></p><ul><li>学习 复制 命令前, 应该先学会 <strong>怎么样选中 要复制的代码</strong></li><li>在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 <strong>可视模式</strong></li><li>vi/vim 中提供了 <strong>三种</strong> 可视模式, 可以方便程序员的选择 <strong>选中文本的方式</strong></li><li>按 ESC 可以放弃选中, 返回到 <strong>命令模式</strong></li></ul><table><thead><tr><th>命令</th><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>v</td><td>可视模式</td><td>从光标位置开始按照正常模式选择文本</td></tr><tr><td>V</td><td>可视化模式</td><td>选中光标经过的完整行</td></tr><tr><td>Ctrl + v</td><td>可是块模式</td><td>垂直方向选中文本</td></tr></tbody></table><p><strong>6) 撤销和恢复撤销(保命指令)</strong></p><p>在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作</p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>undo</td><td>撤销上次的命令(ctrl + z)</td></tr><tr><td>Ctrl + r</td><td>uredo</td><td>恢复撤销的命令</td></tr></tbody></table><p><strong>7) 删除文本</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>x</td><td>cut</td><td>删除光标所在的字符,或者选中的文字</td></tr><tr><td>d(移动命令)</td><td>delete</td><td>删除移动命令对应的内容</td></tr><tr><td>dd</td><td>delete</td><td>删除光标所在行, 可以删除多行</td></tr><tr><td>D</td><td>delete</td><td>删除至行尾</td></tr></tbody></table><p>提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本</p><p>删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dw</td><td>从光标位置删除到单词末尾</td></tr><tr><td>d}</td><td>从光标位置删除到段落末尾</td></tr><tr><td>ndd</td><td>从光标位置向下连续删除 n 行</td></tr></tbody></table><p><strong>8) 复制和剪切</strong></p><ul><li>vi/vim 中提供有一个 被复制文本的缓冲区<ul><li>复制 命令会将选中的文字保存在缓冲区</li><li>删除 命令删除的文字会被保存在缓冲区</li><li>在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置</li></ul></li></ul><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>copy</td><td>复制行</td></tr><tr><td>d(剪切命令)</td><td>delete</td><td>剪切</td></tr><tr><td>dd(剪切)</td><td>delete</td><td>剪切一行, 可以 ndd 剪切n行</td></tr><tr><td>p</td><td>paste</td><td>粘贴</td></tr></tbody></table><p>提示:</p><ul><li>命令 d 、x 类似于图形界面的 <strong>剪切操作</strong>  – ctrl + x</li><li>命令 y 类似于 图形界面的 <strong>复制操作</strong> – Ctrl + </li><li>命令 p 类似于图形界面的 <strong>粘贴操作</strong> – Ctrl + v</li><li>vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换.</li></ul><p>注意</p><ul><li>vi中的 <strong>文本缓冲区</strong> 和 系统的 <strong>剪切板</strong> 不是同一个</li><li>所以在其他软件中使用 <code>Ctrl + C</code> 复制的内容, 不能再 <code>vi</code> 中通过 <code>p</code> 命令粘贴</li><li>可以在 <strong>编辑模式</strong> 下使用 <strong>鼠标右键粘贴</strong></li></ul><p><strong>9) 替换</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th><th>工作模式</th></tr></thead><tbody><tr><td>r</td><td>replace</td><td>替换当前字符</td><td>命令模式</td></tr><tr><td>R</td><td>replace</td><td>替换当前行光标后的字符</td><td>替换模式</td></tr></tbody></table><ul><li><code>R</code> 命令可以进入 <strong>替换模式</strong>, 替换完成后, 按下<code>ESC</code> , 按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></li><li><strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>, 对文件进行 <strong>轻量级的修改</strong></li></ul><p><strong>10) 缩排和重复执行</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>&gt;&gt;</td><td>向右增加缩进</td></tr><tr><td>&lt;&lt;</td><td>向左减少缩进</td></tr><tr><td>.</td><td>重复上次命令</td></tr></tbody></table><ul><li><strong>缩进命令</strong> 在开发程序时, <strong>统一增加代码的缩进</strong> 比较有用!<ul><li>一次性 <strong>在选中代码前增加 4 个空格,</strong>  就叫做 <strong>增加缩进</strong></li><li>一次性 <strong>在选中代码前删除 4 个空格</strong>,  就叫做 <strong>较少缩进</strong></li></ul></li><li>在 <strong>可视模式</strong> 下, 缩排命令 主需要使用 一个 <code>&gt;</code> 或者 <code>&lt;</code></li></ul><p>在程序中, <strong>缩进</strong> 通常用来表示代码的归属关系</p><ul><li><strong>前面空格越少, 代码的级别越高</strong></li><li><strong>前面空格越多, 代码的级别越低</strong></li></ul><p><strong>11) 查找</strong></p><p>常规查找</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>/str</td><td>查找str</td></tr></tbody></table><ul><li><p>查找到指定内容之后, 使用 <code>Next</code> 查找下一个出现的位置</p><ul><li><code>n</code> : 查找下一个</li><li><code>N</code> : 查找上一个</li></ul></li><li><p>如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可</p></li><li><p>单词快速匹配</p></li></ul><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>向后查找当前光标所在单词</td></tr><tr><td>#</td><td>向前查找当前光标所在单词</td></tr></tbody></table><ul><li>在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过</li></ul><p><strong>12) 查找并替换</strong></p><ul><li>在 <code>vi/vim</code> 中查找和替换命令需要在 <strong>末行模式</strong> 下执行</li><li>记忆命令格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s///g</span><br></pre></td></tr></table></figure><ol><li> 全局替换</li></ol><ul><li><p>一次向 替换文件中的 所有出现的旧文本</p></li><li><p>命令格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/旧文本/新文本/g</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>可视区域替换</li></ol><ul><li><strong>先选中</strong> 要替换文字的 <strong>范围</strong></li><li>命令格式如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/旧文本/新文本/g</span><br></pre></td></tr></table></figure><ol start="3"><li>确认替换：</li></ol><p>c confirm 确认</p><ul><li><p>如果把末尾的 <code>g</code> 改成 <code>gc</code>  在替换的时候, 会有提示! 推荐使用</p></li><li><p>命令格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/旧文本/新文本/gc</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>y</code> - <code>yes</code> 替换</li><li><code>n</code> - <code>no</code> 不替换</li><li><code>a</code> - <code>all</code> 替换所有</li><li><code>q</code> -<code>quit</code> 退出替换</li><li><code>l</code> - <code>last</code> 最后一个, 并把光标移动到行首</li><li><code>^E</code> 向下滚屏</li><li><code>^Y</code> 向上滚屏</li></ol><h2 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo命令有点类似于我们在java se阶段学习的 System.out.print(&quot;hello&quot;)</span><br><span class="line">但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样</span><br></pre></td></tr></table></figure><p><strong>使用者权限：所有用户</strong></p><ul><li><code>echo string</code> 将字符串输出到控制台 ,  通常和 <strong>重定向</strong> 联合使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo hello world</span><br><span class="line"></span><br><span class="line"># 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号</span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p><strong>6.3 重定向 <code>&gt;</code>(覆盖) 和 <code>&gt;&gt;</code> (追加)</strong> </p><p><img src="assets/1558435686066-1576721493121.png" alt="1558435686066"></p><ul><li>默认情况下 <strong>命令的结果</strong> 输出到 <strong>控制台</strong></li><li>通过 <strong>重定向</strong> 可以将结果 <strong>输出到文件</strong></li></ul><p><strong>6.2.3 实现</strong></p><ul><li><strong>第一步: 将命令的成功结果 覆盖 指定文件内容</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  传智博客 &gt;czbk-txt.txt</span><br></pre></td></tr></table></figure><p>执行结果如下（czbk-txt.txt文件如果没有会自动创建）</p><p><img src="assets/1576721910460.png" alt="1576721910460"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>结果 &gt; 文件名</td><td><code>&gt;</code> 表示输出, 会覆盖文件的原有内容</td></tr></tbody></table><ul><li><h5 id="第二步-将命令的成功结果-追加-指定文件的后面"><a href="#第二步-将命令的成功结果-追加-指定文件的后面" class="headerlink" title="第二步: 将命令的成功结果 追加  指定文件的后面"></a>第二步: 将<strong>命令的成功结果</strong> <strong>追加</strong>  指定文件的后面</h5></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  黑马程序员 &gt;&gt; czbk-txt.txt</span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><img src="assets/1576721980097.png" alt="1576721980097"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt;&gt; 文件名</td><td><code>&gt;&gt;</code> 表示追加, 会将内容追加到已有文件的末尾</td></tr></tbody></table><ul><li><h5 id="第三步-将命令的失败结果-追加-指定文件的后面"><a href="#第三步-将命令的失败结果-追加-指定文件的后面" class="headerlink" title="第三步: 将命令的失败结果 追加 指定文件的后面"></a>第三步: 将<strong>命令的失败结果</strong> <strong>追加</strong> 指定文件的后面</h5></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 不存在的目录  &amp;&gt;&gt;  error.log</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576722167942.png" alt="1576722167942"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>命令  <code>&amp;&gt;&gt;</code> 文件</td><td><code>&amp;&gt;&gt;</code> 表示不区分错误类型 都放到 日志中</td></tr></tbody></table><blockquote><p>总结</p><ul><li>通过 <code>命令 &gt; 文件</code>  将<strong>命令的成功结果</strong> <strong>覆盖</strong> 指定文件内容</li><li>通过 <code>命令 &gt;&gt; 文件</code>   将<strong>命令的成功结果</strong> <strong>追加</strong>  指定文件的后面</li><li>通过 <code>命令 &amp;&gt;&gt; 文件</code> 将 <strong>命令的失败结果</strong> <strong>追加</strong> 指定文件的后面</li></ul></blockquote><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><p>AWK是一种处理文本文件的语言，是一个强大的文本分析工具。</p><p>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p><p><strong>具体语法如下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] &#x27;script&#x27; var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><p><strong>1、数据准备：czbk-txt.txt文本内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 68 99 26</span><br><span class="line">lisi 98 66 96</span><br><span class="line">wangwu 38 33 86</span><br><span class="line">zhaoliu 78 44 36</span><br><span class="line">maq 88 22 66</span><br><span class="line">zhouba 98 44 46</span><br></pre></td></tr></table></figure><p> <strong>2、搜索含有 zhang  和 li 的学生成绩：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat czbk-txt.txt | awk &#x27;/zhang|li/&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577178031588.png" alt="1577178031588"></p><p><strong>指定分割符, 根据下标显示内容</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>awk   -F  ‘,’    ‘{print $1, $2, $3}’  文件</td><td>操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容</td></tr></tbody></table><p>选项</p><table><thead><tr><th>选项</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td><code>-F &#39;,&#39;</code></td><td>field-separator</td><td>使用 <strong>指定字符</strong> 分割</td></tr><tr><td><code>$ + 数字</code></td><td></td><td>获取<strong>第几段</strong>内容</td></tr><tr><td><code>$0</code></td><td></td><td>获取 <strong>当前行</strong> 内容</td></tr><tr><td><code>NF</code></td><td>field</td><td>表示当前行共有多少个字段</td></tr><tr><td><code>$NF</code></td><td></td><td>代表 最后一个字段</td></tr><tr><td><code>$(NF-1)</code></td><td></td><td>代表 倒数第二个字段</td></tr><tr><td><code>NR</code></td><td></td><td>代表 处理的是第几行</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看文档内容</span><br><span class="line">cat czbk-txt.txt </span><br><span class="line">#直接输出</span><br><span class="line">cat score.txt | awk -F &#x27; &#x27; &#x27;&#123;print $1,$2,$3&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577178523300.png" alt="1577178523300"></p><p><strong>指定分割符, 根据下标显示内容</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>awk   -F  ‘ ‘    ‘{OFS=”===”}{print $1, $2, $3}’  1.txt</td><td>操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容</td></tr></tbody></table><p>选项</p><table><thead><tr><th>选项</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td><code>OFS=&quot;字符&quot;</code></td><td>output field separator</td><td>向外输出时的段分割字符串</td></tr></tbody></table><table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td>\b</td><td>退格</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>制表符</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 按照 === 进行分割, 打印 第一段 第二段 第三段</span><br><span class="line">cat  czbk-txt.txt | awk -F &#x27; &#x27; &#x27;&#123;OFS=&quot;===&quot;&#125;&#123;print $1,$2,$3&#125;&#x27;</span><br><span class="line"># 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段</span><br><span class="line">cat czbk-txt.txt| awk -F &#x27; &#x27; &#x27;&#123;OFS=&quot;\t&quot;&#125;&#123;print $1,$2,$3&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577178563336.png" alt="1577178563336"></p><p><img src="assets/1577179227699.png" alt="1577179227699"></p><p><strong>调用 awk 提供的函数</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>awk   -F  ‘,’    ‘{print  toupper($2)}’  1.txt</td><td>操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容</td></tr></tbody></table><p>常用函数如下:</p><table><thead><tr><th>函数名</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>toupper()</td><td>upper</td><td>字符 转成 大写</td></tr><tr><td>tolower()</td><td>lower</td><td>字符 转成小写</td></tr><tr><td>length()</td><td>length</td><td>返回 字符长度</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打印第一段内容</span><br><span class="line"> cat czbk-txt.txt | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"># 将第一段内容转成大写 且 显示 </span><br><span class="line"> cat czbk-txt.txt | awk -F &#x27; &#x27; &#x27;&#123;print toupper($1)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577180402362.png" alt="1577180402362"></p><p><strong>求指定学科平均分</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>awk ‘BEGIN{初始化操作}{每行都执行} END{结束时操作}’   文件名</td><td>BEGIN{ 这里面放的是执行前的语句 }<br />{这里面放的是处理每一行时要执行的语句}<br />END {这里面放的是处理完所有的行后要执行的语句 }</td></tr></tbody></table><p><strong>查看czbk-txt.txt 文件内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat czbk-txt.txt </span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577180698120.png" alt="1577180698120"></p><p><strong>查看总分</strong></p><p>注意：这里计算的是第4列的总分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat czbk-txt.txt| awk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577180583110.png" alt="1577180583110"></p><p><strong>查看总分, 总人数</strong></p><p>注意：这里计算的是第4列的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat czbk-txt.txt| awk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total, NR&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577180635136.png" alt="1577180635136"></p><p><strong>查看总分, 总人数, 平均分</strong></p><p>注意：这里计算的是第4列的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat czbk-txt.txt | awk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total, NR, (total/NR)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577180660454.png" alt="1577180660454"></p><blockquote><p>总结</p><p>awk在使用过程中主要用作分析</p><p>简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理</p></blockquote><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软连接其实就类似于我们在Windows中的【快捷方式】</span><br></pre></td></tr></table></figure><ul><li>在Linux<strong>文件名</strong> 和 <strong>内容</strong> 是两个文件, 分开的!<img src="assets/1558439106175.png" alt="1558439106175"></li></ul><ul><li><p>创建软链接的原理, 如下<img src="assets/1558439158250.png" alt="1558439158250"></p><p>为什么有软连接？</p><p>因为 某些文件和目录 的 <strong>路径很深</strong>, 所以 需要增加 <strong>软链接(快捷方式)</strong></p></li></ul><p><strong>使用者权限：所有用户</strong></p><p><strong>语法如下:</strong></p><table><thead><tr><th>命令</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td>ln <strong>-s</strong>  目标文件绝对路径  快捷方式路径</td><td>link</td><td>给目标文件增加一个软链接, 通俗讲就是快捷方式</td></tr></tbody></table><p><strong>给home/itcast/txtfile.txt文件增加软连接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln  -s /home/itcast/txtfile.txt    czbk-txt</span><br></pre></td></tr></table></figure><p>上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到</p><p>czbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的</p><p>如下图</p><p><img src="assets/1576723058556.png" alt="1576723058556"></p><blockquote><p>总结</p><p>通过 `ln -s 源文件的绝对路径 其实就是给<strong>目标文件</strong> 增加 <strong>快捷方式</strong></p></blockquote><h2 id="find查找"><a href="#find查找" class="headerlink" title="find查找"></a>find查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引子</span><br><span class="line">find命令类似与在Windows中全局查找（如下图）</span><br></pre></td></tr></table></figure><p><img src="assets/1576828863833.png" alt="1576828863833"></p><p><strong>find概念</strong></p><p>find命令用来在指定目录下查找文件。</p><p>任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定内容&gt;</span><br></pre></td></tr></table></figure><p><strong>1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.gz&quot;</span><br></pre></td></tr></table></figure><p>执行效果如下图</p><p><img src="assets/1576829221486.png" alt="1576829221486"></p><p><strong>2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -ctime -1</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576829352063.png" alt="1576829352063"></p><p><strong>3、全局搜索czbk</strong></p><p>/代表是全盘搜索,也可以指定目录搜索 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name  &#x27;czbk&#x27;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1576829929308.png" alt="1576829929308"></p><h2 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h2><blockquote><p>注意：</p><p>read命令属于文件范畴的命令</p><p>在下面的演示中，会涉及到shell，shell章节在最后一章</p><p>建议：讲解shell的时候在回过来说下read命令的语法</p><p>我们在综合案例中也会降到read</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引子：</span><br><span class="line">read命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互，</span><br></pre></td></tr></table></figure><p>read命令用于从标准输入读取数值。</p><p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure><p><strong>1、简单读取</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;请您输入网站名: &quot;  </span><br><span class="line"><span class="meta">#</span><span class="bash">读取从键盘的输入</span>  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577409765115.png" alt="1577409765115"></p><p><strong>3、读取文件</strong></p><p>每次调用 read 命令都会读取文件中的 “一行” 文本。当文件没有可读的行时，read 命令将以非零状态退出。</p><p>我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。</p><p>测试文件 test.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">BBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">================传智播客</span><br></pre></td></tr></table></figure><p>脚本如下，可以将脚本放到xxx.sh中进行执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line">cat test.txt | while read line      </span><br><span class="line"><span class="meta">#</span><span class="bash"> cat 命令的输出作为<span class="built_in">read</span>命令的输入,<span class="built_in">read</span>读到&gt;的值放在line中</span></span><br><span class="line">do</span><br><span class="line">   echo &quot;Line $count:$line&quot;</span><br><span class="line">   count=$[ $count + 1 ]          # 注意中括号中的空格。</span><br><span class="line">done</span><br><span class="line">echo &quot;finish&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="assets/1577410272633.png" alt="1577410272633"></p><blockquote><p>总结</p><p>由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。</p><h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><h3 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h3><p><strong>语法</strong><br>    gizp [参数选项] [文件]            压缩文件<br><strong>常用命令</strong></p><ul><li>gzip a.txt    压缩文件</li><li>gzip *           压缩当前目录下所有文件</li><li>gzip -dv *    解压文件并列出详细信息</li></ul><h3 id="gunzip命令"><a href="#gunzip命令" class="headerlink" title="gunzip命令"></a>gunzip命令</h3><p><strong>语法</strong><br>    gunzip [参数] [文件]        解压文件<br><strong>常用命令</strong></p><ul><li>gunzip a.txt    解压文件</li><li>gunzip *           解压当前目录下所有文件</li><li>gunzip -dv *    解压文件并列出详细信息</li></ul><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p><strong>语法</strong><br>    tar [必要参数] [选择参数] [文件]        打包、压缩和解压（文件/文件夹）<br><em>注意：tar本身不具有压缩功能，它是调用压缩功能实现的</em></p><p><strong>参数选项：</strong></p><ul><li>-c 建立新的压缩文件</li><li>-v 显示指令执行过程</li><li>-f &lt;备份文件&gt; 指定压缩文件</li><li>-z 通过gzip指令处理压缩文件</li><li>-t 列出压缩文件中的内容</li><li>-x 表示解压</li></ul><p><strong>常用命令</strong></p><ul><li>tar -cvf 打包文件名 文件名        打包文件并指定打包之后的文件名（仅打包不压缩）</li><li>tar -zcvf 压缩文件名 文件名、文件夹名        压缩文件或者文件夹并指定压缩文件名（打包压缩）</li><li>tar -ztvf 压缩文件名        查看压缩文件中有哪些文件</li><li>tar -zxvf 压缩文件名        解压</li></ul><h3 id="bzip2命令"><a href="#bzip2命令" class="headerlink" title="bzip2命令"></a>bzip2命令</h3><p><strong>语法</strong><br>    bzip2 [参数选项] 文件            压缩<br><font color=#FF0000><em>注意：1.使用新的压缩算法，压缩后的 文件比原来的要小，但是花费时间变长。2. 若没有加上任何参数，bzip2压缩文件后会产生.bz的压缩文件，并删除原始的文件</em></font>   </p><p><strong>常用命令</strong></p><ul><li>bzip2 a.txt         压缩</li></ul><h3 id="bunzip2命令"><a href="#bunzip2命令" class="headerlink" title="bunzip2命令"></a>bunzip2命令</h3><p><strong>语法</strong><br>    bunzip2 [参数选项] 文件        解压<br><strong>参数选项：</strong></p><ul><li>-v 解压缩文件时，显示详细的信息</li></ul><p><strong>常用命令</strong></p><ul><li>bunzip2 a.txt.bz2         解压</li></ul><h2 id="网络与磁盘管理"><a href="#网络与磁盘管理" class="headerlink" title="网络与磁盘管理"></a>网络与磁盘管理</h2><h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><p><strong>语法</strong><br>    ifconfig [参数选项]            显示或配置网络设备的命令<br><strong>常用命令</strong></p><ul><li>ifconfig                  显示激活的网卡信息</li><li>ifongfig ens37 down        关闭网卡</li><li>ifongfig ens37 up           启动网卡</li><li>ifongfig ens37 192.168.23.199        配置ip地址</li><li>ifongfig ens37 192.168.23.199 netmask 255.255.255.0        配置ip地址和子网掩码</li></ul><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p><strong>语法</strong><br>    ifconfig [参数选项]            检测是否与主机联通<br><strong>参数选项：</strong></p><ul><li>-c &lt;完成次数&gt;    设置完成要求回应的次数</li></ul><p><strong>常用命令</strong></p><ul><li>ping <a href="http://www.baidu.com/">www.baidu.com</a>        检测是否与百度联通</li><li>ping -c 2 <a href="http://www.baidu.com/">www.baidu.com</a>        指定接收包的次数</li></ul><h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h3><ul><li>为network status缩写</li></ul><p><strong>语法</strong><br>    netstat [参数选项]            显示网络状态<br><strong>参数选项：</strong></p><ul><li>-a 显示所有连线中的Socker</li><li>-i 显示网卡列表</li></ul><p><strong>常用命令</strong></p><ul><li>netstat -a            显示详细的连接状况</li><li>netstat -i             显示网卡列表</li></ul><h3 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a>lsblk命令</h3><ul><li>为list block缩写</li></ul><p><strong>语法</strong><br>    lsblk [参数选项]            列出硬盘的使用情况<br><strong>参数选项：</strong></p><ul><li>-f 显示系统信息</li></ul><p><strong>常用命令</strong></p><ul><li>lsblk            列出硬盘使用情况</li><li>lsblk -f              显示系统信息</li></ul><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><ul><li>df : disk free(显示磁盘可用空间数目信息及空间节点信息。换句话说，就是查看在任何安装的设备或目录中还剩多少自由空间)</li></ul><p><strong>语法</strong><br>    df [参数选项]            显示目前在linux系统上，硬盘的使用情况<br><strong>参数选项：</strong></p><ul><li>-total    显示所有的信息</li><li>-h         换算成KB，MB，GB等形式进行展示（方便阅读）</li></ul><p><strong>常用命令</strong></p><ul><li>df            显示整个磁盘使用情况</li><li>df 文件夹          显示文件夹使用情况</li><li>df -total                   显示所有的信息</li><li>df -h              将结果变成KB,MB,GB形式展示，利于阅读</li></ul><h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><ul><li>关于挂载：用户<strong>不能</strong>直接访问 硬件设备需要将硬件设备 <strong>挂载</strong> 到 系统目录上,  才可以让用户访问。</li></ul><p><strong>注意：“挂载点”的目录需要以下几个要求：</strong></p><p>（1）目录事先存在，可以用mkdir命令新建目录；</p><p>（2）挂载点目录不可被其他进程使用到；</p><p>（3）挂载点下原有文件将被隐藏。</p><p><strong>使用者权限：所有用户，设置级别的需要管理员</strong><br><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount [-hV]</span><br><span class="line">mount -a [-fFnrsvw] [-t vfstype]</span><br><span class="line">mount [-fnrsvw] [-o options [,...]] device | dir</span><br><span class="line">mount [-fnrsvw] [-t vfstype] [-o options] device dir</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><ul><li>mkdir 文件夹                        创建文件夹（也是创建一个挂载点）</li><li>mount -t auto /dev/cdrom 文件夹            开始挂载</li><li>umount 文件夹                               卸载</li></ul><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="yum使用"><a href="#yum使用" class="headerlink" title="yum使用"></a>yum使用</h3><p><strong>yum概念</strong></p><ul><li>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</li><li>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package</strong>操作的对象。</li></ul><hr><p><strong>yum常用命令</strong></p><ul><li>1.列出所有可更新的软件清单命令：yum check-update</li><li>2.更新所有软件命令：yum update</li><li>3.仅安装指定的软件命令：yum install <package_name></li><li>4.仅更新指定的软件命令：yum update <package_name></li><li>5.列出所有可安裝的软件清单命令：yum list</li><li>6.删除软件包命令：yum remove <package_name></li><li>7.查找软件包 命令：yum search <keyword></li><li>8.清除缓存命令:<ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul> <strong>注意：</strong> </li></ul><ol><li>必须联网</li><li>不同的服务通过yum命令连接远程yum源进行查找、下载、安装</li></ol><h4 id="安装Tree"><a href="#安装Tree" class="headerlink" title="安装Tree"></a>安装Tree</h4><p><strong>yum命令</strong></p><ul><li>yum -y install tree            安装tree</li><li>tree                        执行tree,展示当前目录结构</li><li>yum remove tree                移除tree</li><li>yum list tom*                    找出以tom为开头的软件名称</li><li><h4 id="yum源设置"><a href="#yum源设置" class="headerlink" title="yum源设置"></a>yum源设置</h4></li></ul><p><strong>设置命令</strong></p><ul><li>yum install -y wget            安装下载工具wget</li><li>wget -O CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a>        下载阿里云文件</li><li>yum clean all                     清理之前的缓存，并重新加载yum</li><li>yum makecache                建立一个缓存文件</li><li>yum search tomcat                查找软件，验证阿里云的yum源时是否可以正常使用</li></ul><h3 id="rpm使用"><a href="#rpm使用" class="headerlink" title="rpm使用"></a>rpm使用</h3><p><strong>1、rpm介绍</strong></p><p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p><p><strong>2、rpm与yum区别</strong></p><p>rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法: rpm [选项...]</span><br></pre></td></tr></table></figure><p><strong>rpm包</strong></p><blockquote><p>注意：</p><p>扩展名为.rpm的包</p><p>可以理解成是Windows中的.exe文件</p></blockquote><p><strong>安装rpm软件包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 软件全包名</span><br></pre></td></tr></table></figure><p><strong>卸载rpm软件包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 软件全包名      </span><br></pre></td></tr></table></figure><p><strong>列出所有安装过的包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></table></figure><p><strong>查询软件包信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi 软件全包名</span><br></pre></td></tr></table></figure><p><strong>查看文件安装位置</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql 软件全包名</span><br></pre></td></tr></table></figure><h3 id="shell使用"><a href="#shell使用" class="headerlink" title="shell使用"></a>shell使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。</span><br><span class="line">而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。</span><br></pre></td></tr></table></figure><ul><li>shell就是在操作系统和应用程序之间的一个命令翻译工具</li></ul><p><strong>shell的使用方式</strong></p><ol><li>手工方式： 逐行输入命令，逐行进行确认执行</li><li>脚本方式： 把手工执行的命令，写到一个文件中，然后运行文件，这个文件就叫脚本文件。</li></ol><h4 id="shell入门"><a href="#shell入门" class="headerlink" title="shell入门"></a>shell入门</h4><p><strong>1.编写第一个shell</strong></p><ul><li>新建一个后缀名为sh</li><li>书写内容<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是临时shell脚本</span></span><br><span class="line">echo &#x27;nihao</span><br><span class="line">echo &#x27;xxsleo&#x27;</span><br></pre></td></tr></table></figure></li><li>执行</li></ul><h4 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h4><ul><li>单行注释： # </li><li>多行注释：</li></ul><ol><li>:&lt;&lt;!    注释内容 ！</li><li>&lt;&lt;字符 注释内容    字符</li></ol><h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><p><strong>1. 定义变量</strong></p><ul><li>普通变量<br>  方式一：<pre><code>      变量名 = 变量值          &lt;font color=#FF0000&gt;变量值必须是一个整体，中间没有特殊字符&lt;/font&gt;</code></pre>  方式二：<pre><code>      变量名 = &#39;变量值&#39;      &lt;font color=#FF0000&gt;单引号中的内容，原样赋值&lt;/font&gt;</code></pre>  方式三：<pre><code>      变量名 = &quot;变量值&quot;      &lt;font color=#FF0000&gt;如果双引号里面有其他变量，会把变量的结果进行拼接，然后赋值&lt;/font&gt;</code></pre>  <strong>习惯：数字不加引号，其他默认加双引号</strong></li><li>命令变量<br>  方式一：<pre><code>      变量名=`命令`      &lt;font color=#FF0000&gt;``为反引号&lt;/font&gt;</code></pre>  方式二：<pre><code>      变量名=$(命令)</code></pre></li></ul><p><em>注意：等号右边和左边不能加空格</em></p><ol start="2"><li><p>使用变量<br> 方式一:</p><pre><code> $变量名     非标准写法，省事</code></pre><p> 方式二：</p><pre><code> &quot;$变量名&quot;     非标准写法，省事</code></pre><p> 方式三：</p><pre><code> $&#123;变量名&#125;     在双引号里面要用变量的值</code></pre><p> 方式四：</p><pre><code> &quot;$&#123;变量名&#125;&quot; 标准使用方式</code></pre></li><li><p>只读变量（类似与final)</p></li></ol><ul><li>变量名前面加    readonly 变量名</li></ul><ol start="4"><li>删除变量</li></ol><ul><li>变量名前面加    unset 变量名</li></ul><h4 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h4><ul><li>   定义数组        数组名={val1,val2,val3}         arr=(1 2 3)</li><li>   给数组的元素赋值   数组名[索引]=值                arr[0]=1</li><li>   获取元素        $ { 数组名[下标]}                $ {arr[0]}</li><li> 获取长度        $ { #数组名[*]}                 $ { #arr[*]}<pre><code>             \$ &#123; \#数组名[@]&#125;              \$ &#123; \#arr[@]&#125;</code></pre></li></ul><h4 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shell 和其他编程一样，**支持**包括：算术、关系、布尔、字符串等运算符。</span><br><span class="line"></span><br><span class="line">原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。</span><br><span class="line"></span><br><span class="line">expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</span><br><span class="line"></span><br><span class="line">例如，两个数相加,我们还是利用上面的例子test-shell.sh </span><br></pre></td></tr></table></figure><p><strong>1、算数运算符</strong></p><p>val=<code>expr 2 + 2</code><br>echo “相加之后的结果为：” $val</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td>[ $a == $b ] 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td>[ $a != $b ] 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 **[ $a == $b ]**。</p><p><strong>2.字符串运算符</strong><br>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">检测两个字符串是否相等，相等返回 true。</td><td align="left">[ $a = $b ] 返回 false。</td></tr><tr><td align="left">!=</td><td align="left">检测两个字符串是否相等，不相等返回 true。</td><td align="left">[ $a != $b ] 返回 true。</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true。</td><td align="left">[ -z $a ] 返回 false。</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否为0，不为0返回 true。</td><td align="left">[ -n “$a” ] 返回 true。</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否为空，不为空返回 true。</td><td align="left">[ $a ] 返回 true。</td></tr></tbody></table><p><strong>3、关系运算符</strong></p><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：<br>| 运算符 | 说明                                                  | 举例                       |<br>| :—– | :—————————————————- | :————————- |<br>| -eq equals    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |<br>| -ne not equals  | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |<br>| -gt greater than  | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |<br>| -lt less than   | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |<br>| -ge greater equals  | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |<br>| -le less equals | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |<br><strong>4、布尔运算符</strong></p><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td align="left">[ ! false ] 返回 true。</td></tr><tr><td align="left">-o</td><td align="left">或运算，有一个表达式为 true 则返回 true。</td><td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td align="left">-a</td><td align="left">与运算，两个表达式都为 true 才返回 true。</td><td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr><tr><td align="left"><strong>5、逻辑运算符</strong></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>假定变量 a 为 10，变量 b 为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑的 AND</td><td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td align="left">||</td><td align="left">逻辑的 OR</td><td align="left">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td></tr></tbody></table><p><font color=#FF0000>使用这些运算符前后要加空格</font></p><h4 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句；</span><br><span class="line">在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。</span><br></pre></td></tr></table></figure><p><strong>1、if 语句：</strong></p><p><strong>主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>2、if else 语句：</strong></p><p><strong>主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>3、if else-if else 语句：</strong></p><p><strong>主要用于判断，相当于java se中的if else-if else</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>4、case … esac语句</strong></p><p><strong>主要用于分支条件选择，相当于java se中的switch case循环</strong></p><p><strong>case … esac</strong> 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><p>还是采用之前的例子test-shell.sh</p><p>case … esac 语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case 后为取值，值可以为变量或常数。</p><p>值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。</p><p>下面通过v的值进行case–esac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v=&quot;czbk&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$v&quot; in</span><br><span class="line">   &quot;czbk&quot;) echo &quot;传智播客&quot;</span><br><span class="line">   ;;</span><br><span class="line">   &quot;baidu&quot;) echo &quot;baidu 搜索&quot;</span><br><span class="line">   ;;</span><br><span class="line">   &quot;google&quot;) echo &quot;google 搜索&quot;</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><font color=#FF0000>注意：)不能少</font></p><p><strong>5、for 循环</strong></p><p><strong>主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh</strong></p><p>for循环格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>顺序输出当前列表中的字母：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in A B C D E F G </span><br><span class="line">do</span><br><span class="line">    echo &quot;顺序输出字母为: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>6、while循环</strong></p><p>主要用于循环，相当于java se中的while循环</p><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据 </p><p>语法格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 </p><p>还是采用之前的例子test-shell.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=10 ))</span><br><span class="line">do</span><br><span class="line">    echo &quot;输出的值为：&quot;$int</span><br><span class="line">    ((int++))#let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><font color=#FF0000>注意：((int++))两个括号都不能少</font></p><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">无参无返回值的方法</span></span><br><span class="line">method() &#123;</span><br><span class="line">        echo &quot;函数执行了!&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">有参无返回值的方法</span></span><br><span class="line">method2()&#123;</span><br><span class="line">        echo &quot;接收到的第一个参数$1&quot;</span><br><span class="line">        echo &quot;接收到的第二个参数$2&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">有参有返回值的方法</span></span><br><span class="line">method3() &#123;</span><br><span class="line">        echo &quot;接收到的第一个参数$1&quot;</span><br><span class="line">        echo &quot;接收到的第二个参数$2&quot;</span><br><span class="line">        return $(($1 + $2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">方法的调用</span></span><br><span class="line">method</span><br><span class="line">method2 1 2</span><br><span class="line">method3 10 20</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>函数返回值在调用该函数后通过 $? 来获得。</p><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p></blockquote><ul><li>练习<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方法的练习</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在方法中键盘录入两个整数，返回这两个整数的和</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span> 变量名 --- 表示把键盘录入的数据赋值给这个变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method()&#123;</span><br><span class="line">        echo &quot;请输入第一个数&quot;</span><br><span class="line">        read number1</span><br><span class="line">        echo &quot;请输入第二个数&quot;</span><br><span class="line">        read number2</span><br><span class="line">        echo &quot;两个数字分别为&quot;$&#123;number1&#125;&quot;,&quot;$&#123;number2&#125;&quot; &quot;</span><br><span class="line">        return  $(($number1+$number2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">方法的调用</span></span><br><span class="line">method</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><font color=#FF0000>注意：return ￥（）</font></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>输入命令时，用户是什么，当前位置是什么</li><li>记准确命令的单词拼写，当出错时，记得找这个原因</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day11-19-删除链表的倒数第N个结点</title>
      <link href="/2022/01/27/Algorithm/Day10-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2022/01/27/Algorithm/Day10-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>链表中节点的数目在范围 [0, 100] 内</li><li>0 &lt;= Node.val &lt;= 100<h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2></li><li>遍历链表，前后两对两对比大小<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = head.next.val;</span><br><span class="line">            head.val = d;</span><br><span class="line">            head.next.val = head.val;</span><br><span class="line">            head = head.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：仅有部分通过</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>虚头结点加，链表变换位置</li><li>思路与算法</li></ul><p>也可以通过迭代的方式实现两两交换链表中的节点。</p><p>创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。</p><p>如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p><p>具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。</p><p>temp.next = node2<br>node1.next = node2.next<br>node2.next = node1<br>完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp = node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p><p>两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode node1 = temp.next;</span><br><span class="line">            ListNode node2 = temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>时间复杂度：O(n)，其中 nn 是链表的节点数量。需要对每个节点进行更新指针的操作。</p><p>空间复杂度：O(1)。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>总是想不到更加巧妙一点的方法</li><li>不能很好的利用虚头节点</li><li>多练，多总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day010-24-两两交换链表中的节点</title>
      <link href="/2022/01/26/Algorithm/Day11-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2022/01/26/Algorithm/Day11-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://gitee.com/xu-liuwang/pic-go-picutre-bed/raw/master/img//%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%85%83%E7%B4%A0.png" alt="删除链表倒数第N个元素"></p><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><p>输入：head = [1], n = 1<br>输出：[]</p><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：head = [1,2], n = 1<br>输出：[1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>链表中结点的数目为 sz<br>1 &lt;= sz &lt;= 30<br>0 &lt;= Node.val &lt;= 100<br>1 &lt;= n &lt;= sz</p><h1 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h1><ul><li>遍历链表，得到链表节点数count,count - n +1 为正序位置，删除该位置的元素</li><li>代码:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode pred = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = i; i &lt; count - n + <span class="number">1</span>; i++)&#123; <span class="comment">// count - n为删除元素的前一个</span></span><br><span class="line">           ** pred = pred.next; **</span><br><span class="line">        &#125;</span><br><span class="line">            pred.next = pred.next.next;</span><br><span class="line">        <span class="keyword">return</span> pred.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：空指针异常</li><li>参考官方：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>感觉是一样的，但是不能运行<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2></li><li>想到了快慢指针的做法，但是没想到怎么设计两个指针的走法</li><li>参考代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;<span class="comment">//dummy和second一样变了？</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li><li>其他版本<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记住 待删除节点slow 的上一节点</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一节点的next指针绕过 待删除节点slow 直接指向slow的下一节点</span></span><br><span class="line">        prev.next = slow.next;</span><br><span class="line">        <span class="comment">// 释放 待删除节点slow 的next指针, 这句删掉也能AC</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>区别</strong> 第一个的fast比slow多走一步，遍历结束时，第一个停在被删除元素的上一个位置，而第二个的位置为被删除元素位置，需要有一个pred记录前一个位置。当slow改变时，dummy都会改变</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ol><li>思路不清晰</li><li>以后可以找纸笔画一下</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day09-206-反转链表</title>
      <link href="/2022/01/25/Algorithm/Day09-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/01/25/Algorithm/Day09-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>链表中节点的数目范围是 [0, 5000]</li><li>-5000 &lt;= Node.val &lt;= 5000</li></ul><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>递归遍历链表，获得其中的值，利用尾插法创建一个新的链表，达到反转</li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置虚拟头结点。</span></span><br><span class="line">        ListNode dummyhead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        ListNode temp = dummyhead;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode();</span><br><span class="line">        res.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode p = <span class="keyword">new</span>  ListNode();</span><br><span class="line">            p.val = temp.next.val;</span><br><span class="line">            p.next = res.next;  <span class="comment">//尾插法</span></span><br><span class="line">            res.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：超出内存限制</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>迭代，双指针</li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = cur.next;  <span class="comment">//用来储存下一个节点的位置</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;                <span class="comment">// 类似于头插法</span></span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行成功，参考leet官方解答</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>只能想到暴力解法，对一些灵活思路还是不熟悉</li><li>多练！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day08-707-设计链表</title>
      <link href="/2022/01/24/Algorithm/Day08-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/01/24/Algorithm/Day08-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul><li>所有val值都在 [1, 1000] 之内。</li><li>操作次数将在  [1, 1000] 之内。</li><li>请不要使用内置的 LinkedList 库。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><ul><li>注意虚头节点，也就是哨兵的使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    ListNode head,tail;<span class="comment">//Sentinel node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode cur = tail;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问?"></a>疑问?</h2></li><li>deleteAtIndex(int index)中为什么要 index &gt;= size排除， 难道不能删最后一个吗？我把deleteAtindex改为以下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != size) &#123;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：会部分运行错误。</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>复习了链表基本操作</li><li>还是有不理解的地方，抓紧时间理解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day07-203-移除链表元素</title>
      <link href="/2022/01/23/Algorithm/Day07-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2022/01/23/Algorithm/Day07-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], val = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = <span class="number">1</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul><li>列表中的节点数目在范围 [0, 104] 内</li><li>1 &lt;= Node.val &lt;= 50</li><li>0 &lt;= val &lt;= 50</li></ul><h2 id="Java中链表定义"><a href="#Java中链表定义" class="headerlink" title="Java中链表定义"></a>Java中链表定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>遍历链表，查找是否有和val相同的元素，有的话，删除，重新连接。</li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：测试通过，但是执行出错，仔细一想，是没有考虑到头结点会和val一样。</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>参考LeetCode官方解答，添加了哑节点，用来避免头结点删除出错。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2></li><li>当头结点需要删除时另做考虑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除值相同的头结点后，可能新的头结点也值相等，用循环解决</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.val==val)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode prev=head;</span><br><span class="line">        <span class="comment">//确保当前结点后还有结点</span></span><br><span class="line">        <span class="keyword">while</span>(prev.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.val==val)&#123;</span><br><span class="line">                prev.next=prev.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev=prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：lewis-dXStAbdZEw</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/remove-linked-list-elements/solution/203yi-chu-lian-biao-yuan-su-by-lewis-dxstabdzew/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问?"></a>疑问?</h2></li><li>为什么要return head; ?</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ol><li>复习了链表的知识，如遍历判断时，先考虑是否为null,要考虑头结点等。</li><li>对链表的了解还是不足。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day06-算法数组总结</title>
      <link href="/2022/01/22/Algorithm/Day06-%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/22/Algorithm/Day06-%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h1><h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><em>(详情见)[<a href="https://xxsleo.github.io/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">https://xxsleo.github.io/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE</a> ]</em><br><strong>注意</strong></p><ul><li>暴力解法时间复杂度：O(n)</li><li>二分法时间复杂度： O(logn)</li><li>循环不变量原则</li></ul><p><strong>代码再写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = first + (last - first)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                last = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果： 超出时间限制，检查几遍觉得没问题哇，仔细对比才发现 while里没加等号，应是(first &lt;= last),不加等号可能会造成有些情况死循环。</li></ul><p><strong>最终再写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(first &lt;= last) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = first + (last - first)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                last = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><em>(详情见)[<a href="https://xxsleo.github.io/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">https://xxsleo.github.io/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0</a> ]</em><br><strong>注意</strong></p><ul><li>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li><li>暴力解法时间复杂度：O(n2)</li><li>双指针时间复杂度： O(n)</li></ul><p><strong>代码再写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：成功运行，还是要记得快慢指针为变量，相当于i的位置。 巧妙地是if,只有不和val一样，慢指针值才变。<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3></li></ul><p><em>(详情见)[<a href="https://xxsleo.github.io/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">https://xxsleo.github.io/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84</a> ]</em><br><strong>注意</strong></p><ul><li>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li><li>暴力解法时间复杂度：O(n2)</li><li>双指针时间复杂度： O(n)</li></ul><p><strong>代码再写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fastIndex;</span><br><span class="line">        <span class="keyword">int</span> showIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex ++)&#123;</span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result,fastIndex - showIndex + <span class="number">1</span>);</span><br><span class="line">                showIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：测试不成功，经检查发现，sum没有及时更新，sum更新应该减去当前showIndex所指的值。</li><li>改了之后还不行，仔细检查发现if用法不对，因为可能出现减去当前showIndex所指的值之后，sum还&gt;target,导致错过次数。</li></ul><p><strong>最终代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fastIndex;</span><br><span class="line">        <span class="keyword">int</span> showIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex ++)&#123;</span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result,fastIndex - showIndex + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[showIndex];</span><br><span class="line">                showIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><em>(详情见)[<a href="https://xxsleo.github.io/2022/01/21/Algorithm/Day05-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II">https://xxsleo.github.io/2022/01/21/Algorithm/Day05-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II</a> ]</em><br><strong>注意</strong></p><ul><li>循环不变量原则</li><li>考察对代码的掌控能力</li></ul><p><strong>代码再写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, t = <span class="number">0</span>, b = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>, tar = n * n;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= tar)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) mat[t][i] = num++; <span class="comment">// left to right.</span></span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) mat[i][r] = num++; <span class="comment">// top to bottom.</span></span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) mat[b][i] = num++; <span class="comment">// right to left.</span></span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) mat[i][l] = num++; <span class="comment">// bottom to top.</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>结果：成功运行。<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2>  数组这一块的经典题目算是练完了。总之，需要掌握一些排序算法，还有双指针法，来降低时间复杂度，还需要有良好的条件判断能力，处理各种情况。还需努力</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令(1)</title>
      <link href="/2022/01/22/JavaWeb/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20(1)-Linux%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/01/22/JavaWeb/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%20(1)-Linux%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux系统与设置命令"><a href="#Linux系统与设置命令" class="headerlink" title="Linux系统与设置命令"></a>Linux系统与设置命令</h2><h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><ol><li>创建用户：useradd (选项) 用户名</li><li>用户口令:   passwd –</li><li>修改用户：usermod –</li><li>删除用户：userdel –</li><li>退出当前用户：ctrl + d</li></ol><ul><li>输入useradd回车，即可显示选项</li></ul><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><ol><li>创建用户组：groupadd (选项) 用户组名</li><li>修改用户组：groupmod –</li><li>查询用户所属组：groups 用户名</li><li>删除用户组：groupdel 用户组名</li></ol><h3 id="管理用户组内成员"><a href="#管理用户组内成员" class="headerlink" title="管理用户组内成员"></a>管理用户组内成员</h3><p>语法：    gpasswd (选项) 组名</p><ul><li>gpasswd是Linux下的管理工具，用于将一个用户添加到组或者从组中删除。</li><li>-a 添加</li><li>-d 删除</li><li>-A 指定管理员</li><li>-M 指定组成员和-A用途相差不大</li><li>-r 删除密码</li><li>-R 限制用户登入组，只有组中的成员才可以用newgrp加入该组</li></ul><h3 id="日期管理"><a href="#日期管理" class="headerlink" title="日期管理"></a>日期管理</h3><p>语法： date [参数选项]<br><strong>参数选项：</strong></p><ul><li>-d&lt;字符串&gt; : 显示字符串所指的日期与时间。字符串前后必须加上双引号；</li><li>-s&lt;字符串&gt; : 根据字符串来设置日期与时间。字符串前后必须加上双引号；</li><li>-u：显示GMT;</li><li>–help : 在线帮助</li><li>– version ：显示版本信息</li></ul><h3 id="显示用户"><a href="#显示用户" class="headerlink" title="显示用户"></a>显示用户</h3><p>语法：logname [–help][–version]    显示登录账号的信息<br><strong>参数信息：</strong></p><ul><li>–help 在线帮助</li><li>–version 显示版本信息</li></ul><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>语法 ：su [参数选项] [USER]<br><strong>参数选项：</strong></p><ul><li>USER要变更的用户账号</li><li>-c 使用目标用户执行一条命令，而不进入 如： su -c ls root</li></ul><h3 id="id命令"><a href="#id命令" class="headerlink" title="id命令"></a>id命令</h3><p>语法： id [-g][–help][-version] [用户名称]    查看当前用户详细信息（用户id,群组，所属组）</p><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>语法：sudo [参数选项]    提高普通用户的操作权限</p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>语法：top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]    实时显示process的动态<br><strong>各进程（任务）的状态监控属性解释说明：</strong><br>PID — 进程id<br>USER — 进程所有者<br>PR — 进程优先级<br>NI — nice值。负值表示高优先级，正值表示低优先级<br>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>SHR — 共享内存大小，单位kb<br>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU — 上次更新到现在的CPU时间占用百分比<br>%MEM — 进程使用的物理内存百分比<br>TIME+ — 进程使用的CPU时间总计，单位1/100秒<br>COMMAND — 进程名称（命令名/命令行）</p><p><strong>最常见使用</strong></p><ul><li><p>top        实时显示所有的进程信息</p></li><li><p>top -c         实时显示所有的进程信息（显示完整命令）</p></li><li><p>top -p PID    实时显示指定的进程信息</p></li><li><p>结束监控快捷键： q</p></li></ul><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>语法：ps [options] [–help]    查看进程信息     –无法实时监控，查看的为当前信息</p><p><strong>最常见使用</strong></p><ul><li>ps          显示当前正在运行的进程信息</li><li>ps -A         显示系统中所有的进程信息</li><li>ps -ef    显示系统中所有的进程信息(完整信息)</li><li>ps -u user 显示指定用户的进程信息</li></ul><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure><p> <strong>参数说明</strong>：</p><ul><li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li><li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li><li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li></ul><p>杀死一个进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 15642</span><br></pre></td></tr></table></figure><p>强制杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -KILL 15642</span><br></pre></td></tr></table></figure><p>彻底杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 15642</span><br></pre></td></tr></table></figure><p>杀死指定用户所有进程</p><p>1.方法一 过滤出itcast用户进程 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef | grep xxsleo) </span><br></pre></td></tr></table></figure><p>2.方法二，直接杀死</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -u xxsleo</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>上面列举了很多kill进程的命令</p><p>但是我们我们常用的就是kill -9命令，我们常常找到进程的pid</p><p>然后通过kill -9进行杀死进程</p></blockquote><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p>shutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机</p><p>使用者权限：管理员用户</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [-t seconds] [-rkhncfF] time [message]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-t seconds : 设定在几秒钟之后进行关机程序。</li><li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li><li>-r : 关机后重新开机。</li><li>-h : 关机后停机。</li><li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li><li>-c : 取消目前已经进行中的关机动作。</li><li>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。</li><li>-F : 关机时，强迫进行 fsck 动作。</li><li>time : 设定关机的时间。</li><li>message : 传送给所有使用者的警告讯息。</li></ul><p>立即关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br><span class="line">或者</span><br><span class="line">shudown</span><br></pre></td></tr></table></figure><p>指定1分钟后关机，1分钟关机并显示警告信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown +1 “System will shutdown after 1 minutes” </span><br></pre></td></tr></table></figure><p>指定1分钟后重启，并发出警告信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown –r +1 “1分钟后关机重启”</span><br></pre></td></tr></table></figure><h3 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h3><p>reboot命令用于用来重新启动计算机</p><p>使用者权限：管理员、普通（需要验证）用户</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot [-n] [-w] [-d] [-f] [-i]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-n : 在重开机前不做将记忆体资料写回硬盘的动作</li><li>-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</li><li>-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</li><li>-f : 强迫重开机，不呼叫 shutdown 这个指令</li><li>-i : 在重开机之前先把所有网络相关的装置先停止</li></ul><p>开始重新启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>此时我们的虚拟机正在重启<strong>（别忘记使用root用户执行）</strong></p><h3 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启</span><br></pre></td></tr></table></figure><p>who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等</p><p>使用者权限：所有使用者都可使用。</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who - [husfV] [user]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-H 或 –heading：显示各栏位的标题信息列；</li><li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；</li><li>-m：此参数的效果和指定”am i”字符串相同；</li><li>-q 或–count：只显示登入系统的帐号名称和总人数；</li><li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li><li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；</li><li>–help：在线帮助；</li><li>–version：显示版本信息</li></ul><p>显示当前登录系统的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure><p>显示明细(标题)信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -H</span><br></pre></td></tr></table></figure><h3 id="timedatectl命令"><a href="#timedatectl命令" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h3><p><strong>几个小概念：</strong><br>| 项目 | 说明|<br>| ———- | ———-|<br>|时区 | date命令可查看 |<br>| 系统时钟： System Clock | linux OS的时间，date命令可查看 |<br>| 硬件时钟：RTC : Real Time Clock | 主办上电池供电的BIOS时间，hwclock -r 可查看 |<br>| NTP: Network Time Protoctol | 本机时间和实际时间经常会有差别，一般使用NTP服务器进行时间校准 |<br><strong>常用命令：</strong></p><ul><li>timedatectl / timedatectl status        显示系统的当前时间和日期</li><li>timedatectl list-timezones             查看所有可用的时区</li><li>timedatectl set-timezone “Asia/Shanghai”    设置本地时区</li><li>timedatectl set ntp false                     禁用时间同步</li><li>timedatectl set-time “2022-01-20 13:59:00”  设置时间</li><li><strong>timedatectl set-ntp true                   启动时间同步</strong></li></ul><h3 id="clear命令"><a href="#clear命令" class="headerlink" title="clear命令"></a>clear命令</h3><ul><li>clear        清屏</li><li>注意：并不是把之前输入命令删掉，滚动条可以返回</li></ul><h2 id="Linux的目录管理"><a href="#Linux的目录管理" class="headerlink" title="Linux的目录管理"></a>Linux的目录管理</h2><h3 id="目录常用命令"><a href="#目录常用命令" class="headerlink" title="目录常用命令"></a>目录常用命令</h3><ul><li>ls:         列出目录</li><li>cd：     切换目录</li><li>pwd：  显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp:         复制文件或目录</li><li>rm:        移除文件或目录</li><li>mv:        移动文件与目录或修改文件与目录的名称</li></ul><p><strong>自动补全</strong></p><ul><li>在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 <code>tab</code>键</li><li>如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令</li></ul><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p><strong>常用命令：</strong></p><ul><li>ls                  显示不隐藏的文件与文件夹</li><li>ls -l                  显示不隐藏的文件与文件夹的详细信息</li><li>ls -al         显示所有的文件与文件夹的详细信息</li></ul><p><em>注意：</em></p><ul><li>隐藏文件和文件开头为 . </li><li>详细信息从左到右以此为：</li></ul><ul><li><strong>权限（A区域）</strong>, 第一个字符如果是 <code>d</code> 表示目录</li><li><strong>硬链接数（B区域）</strong>, 通俗的讲就是有多少种方式, 可以访问当前目录和文件</li><li><strong>属主（C区域）</strong>, 文件是所有者、或是叫做属主</li><li><strong>属组（D区域）</strong>, 文件属于哪个组</li><li><strong>大小（E区域）：文件大小</strong></li><li><strong>时间（F区域）：最后一次访问时间</strong></li><li><strong>名称（G区域）:文件的名称</strong></li></ul><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><ul><li>pwd显示当前目录<br>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在当前目录的命令。</li></ul><p>使用者权限：所有使用者都可使用。</p><p><strong>查看当前所在目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P</span><br></pre></td></tr></table></figure><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><ul><li>cd 切换目录</li><li>语法： cd 路径        切换目录</li></ul><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><ul><li>为make directory 的缩写</li><li>语法：mkdir [-p] 文件夹的名字    创建目录</li></ul><p>** 常用命令 **</p><ul><li>mkdir 文件夹名        创建目录</li><li>mkdir -p aaa/bbb              创建多级目录</li></ul><h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><ul><li>为remo directory 的缩写</li><li>语法：rmdir [-p] 文件夹名  删除空的目录</li></ul><p><strong>常用命令</strong></p><ul><li>rmdir 文件名        删除目录</li><li>rmdir -p bbb/ccc    删除ccc,如果删完之后bbb是空的，bbb也一起删除</li></ul><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><ul><li>为remo的缩写</li><li>语法：rm [选项] 文件/目录    删除文件或者目录</li></ul><p><strong>选项参数：</strong></p><ul><li>-i 删除前逐一询问确认</li><li>-f 即使原档案属性设为只读，也直接删除，无需逐一确认</li><li>-r 将目录及一下的档案逐一删除</li></ul><p><strong>常用命令</strong></p><ul><li>rm 文件路径        删除文件</li><li>rm -r 目录路径            删除目录和目录里面所有的内容</li></ul><p><em>注意：</em>一般使用rm比rmdir简单</p><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><ul><li>为copy的缩写</li><li>语法：cp [选项] 数据源 目的地   文件复制</li></ul><p><strong>选项参数：</strong></p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件。</li></ul><p><strong>常用命令</strong></p><ul><li>cp aaa/a.txt ccc        将aaa文件夹中的a.txt文件拷贝到ccc文件夹中</li><li>cp -r aaa/* ccc        将aaa文件夹中所有内容拷贝到ccc文件夹中</li></ul><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><ul><li>为move的缩写</li><li>语法：mv [选项] 数据源 目的地        改名/ 移动文件夹（看是否在同一目录下)</li></ul><p><strong>选项参数：</strong></p><ul><li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li></ul><p><strong>常用命令</strong></p><ul><li>mv 数据源 目的地        改名、移动</li></ul><p>** 注意 **</p><table><thead><tr><th align="left">命令格式</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">mv 文件名 文件名</td><td align="left">将源文件名改为目标文件名</td></tr><tr><td align="left">mv 文件名 目录名</td><td align="left">将文件移动到目标目录</td></tr><tr><td align="left">mv 目录名 目录名</td><td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td align="left">mv 目录名 文件名</td><td align="left">出错</td></tr></tbody></table><h2 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h2><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>每个文件的属性由左边第一部分的10个字符来确定。<br>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><ul><li>从左至右用0-9这些数字来表示。</li><li>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><h3 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h3><ul><li>为 change group 的缩写    （更改属组）</li></ul><p><strong>语法如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><ul><li>chgrp -v root aaa        将aaa的属组改为root</li><li>chgrp -R dev-group  /tmp/work</li></ul><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><ul><li>为 change owner 的缩写</li></ul><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown 属主名 文件名     更改属主</span><br><span class="line">chown [参数选项] 属主名:属主名 文件名更改属主和属组</span><br></pre></td></tr></table></figure><p><strong>选项参数:</strong></p><ul><li>-R    处理指定目录以及其子目录下的所有文件</li></ul><p><strong>常用命令:</strong></p><ul><li>chown root aaa        将aaa的属主改为root</li><li>chown root:root         将bbb的属主和属组改为root</li><li>chown -R root:root aaa     将aaa文件夹和里面所有的属主和属组改为root</li></ul><p><em>注意：linux命令区分大小写</em></p><h3 id="chmod权限命令"><a href="#chmod权限命令" class="headerlink" title="chmod权限命令"></a>chmod权限命令</h3><ul><li>为change mode 的缩写</li><li>作用：修改属主、属组、其他用户的权限</li><li>修改方式：<ol><li>数字方式</li><li>符号方式<h4 id="数字方式"><a href="#数字方式" class="headerlink" title="数字方式"></a>数字方式</h4></li></ol></li></ul><p><strong>权限属性</strong><br>| 权限 | 英文 | 缩写 | 数字序号 |<br>|— | — | — | — |<br>| 读 | read | r | 4 |<br>| 写 | write | w | 2 |<br>| 执行 | execute | x | 1 |<br>| 无权限 |  | - | 0 |</p><p><em>列：</em></p><ul><li>rwx = 4 + 2 +1 = 7    </li><li>设置数字5表示可读可执行</li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [参数选项] 数字权限 文件或目录</span><br></pre></td></tr></table></figure><p><strong>参数选项</strong></p><ul><li>-R :  对目前目录下所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>-v ：显示权限变更的详细资料</li></ul><p><strong>数字权限</strong></p><ul><li>数字类型的权限属性，为rwx对应数值相加的和。</li></ul><p><strong>举例</strong></p><ul><li>chmod -R 770 aaa</li></ul><h4 id="符号方式"><a href="#符号方式" class="headerlink" title="符号方式"></a>符号方式</h4><p><strong>符号权限</strong></p><ul><li>user     属主权限     -&gt; u</li><li>group  属组权限   -&gt; g</li><li>others 其他权限   -&gt; o</li><li>全部身份            -&gt; a</li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [参数选项] 符号权限 文件或目录</span><br></pre></td></tr></table></figure><p>符号权限格式：<br>    u/g/o/a        +/-/=(加入、除去、设定)        r/w/x<br><strong>参数选项</strong></p><ul><li>-R :  对目前目录下所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>-v ：显示权限变更的详细资料</li></ul><p><strong>符号权限</strong></p><ul><li>r、w、x、-</li></ul><p><strong>举例</strong></p><ul><li>chmod -R u=rwx,g=rx,o=r a.txt</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day05-59-螺旋矩阵II</title>
      <link href="/2022/01/21/Algorithm/Day05-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2022/01/21/Algorithm/Day05-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59.螺旋矩阵 II"></a>59.螺旋矩阵 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="./img/day05-59.png" alt="day05-59"></p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= n &lt;= 20</li></ul><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>循环每一次变化，由于太复杂，没有理清楚头绪，也没写出来</li></ul><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ul><li>因为自己没有写出来，所以看了很多答案，把觉得最清楚的写在这</li></ul><p><strong>思路</strong></p><ul><li>生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：<br>  定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；<br>  当 num &lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<pre><code>      执行 num += 1：得到下一个需要填入的数字；      更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。</code></pre>  使用num &lt;= tar而不是l &lt; r || t &lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li><li>最终返回mat</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, t = <span class="number">0</span>, b = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>, tar = n * n;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= tar)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) mat[t][i] = num++; <span class="comment">// left to right.</span></span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) mat[i][r] = num++; <span class="comment">// top to bottom.</span></span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) mat[b][i] = num++; <span class="comment">// right to left.</span></span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) mat[i][l] = num++; <span class="comment">// bottom to top.</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>觉得题复杂，麻烦就不想自己动手写了，着急看答案</li><li>还是要多点耐心，慢慢理清头绪</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day04-209-长度最小的子数组</title>
      <link href="/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>定义一个变量，通过循环数组，每次叠加数组的各值和target进行对比</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">return</span> length;</span><br><span class="line">            &#125;</span><br><span class="line">            a += nums[i];</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：解答错误</li><li>原因：没仔细看题，题目说的是长度最小的子数组，这思路，只能找出最先大于target的子数组</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>两个for循环，一个遍历数组，一个使各个值从当前位置相加和target对比。</li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    length = Math.min(length, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">999999</span> ? <span class="number">0</span>:length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考后"><a href="#参考后" class="headerlink" title="参考后"></a>参考后</h2><p><strong>滑动窗口</strong>(本质还是双指针)</p><ul><li>思路：两个’指针’从头开始遍历数组, left指针先不动，right向右移，sum增加，若 target &gt;= sum, 此时 left向右移，开始下一初始位置的寻找，直到left=right.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2></li><li>认真读题！ 不能漏掉关键字！</li><li>学以致用，前几天刚学的双指针，没想到用。</li><li>下去多了解一下math函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day03-977-有序数组的平方</title>
      <link href="/2022/01/19/Algorithm/Day03-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2022/01/19/Algorithm/Day03-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= nums.length &lt;= 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>nums 已按 非递减顺序 排序</li></ul><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>循环数组，使值都变为平方，在用冒泡排序，进行非递减处理</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j+<span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：顺利通过，但是时间复杂度O(n + n^2)太高</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>想到了Java里其实是有内置的排序函数sort()的</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：运行成功，把时间复杂度降到了O(n + nlogn);</li></ul><h2 id="参考后"><a href="#参考后" class="headerlink" title="参考后"></a>参考后</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>思路：</strong><br>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k–] = A[j] * A[j]; 。</p><p>如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k–] = A[i] * A[i]; 。</p><ul><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> index = result.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;</span><br><span class="line">                result[index--] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index--] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>思路没新意，太常规</li><li>对java一些基本函数有遗忘，要加强复习</li><li>多借鉴一些优秀的思路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA复习笔记</title>
      <link href="/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-复习"><a href="#JAVA-复习" class="headerlink" title="JAVA 复习"></a>JAVA 复习</h1><h2 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h2><p>Java基础语法（包括数组等），类与对象（包括对象数组等），String类（包括split等常用方法），继承与多态，抽象类与接口，异常类，面向抽象原则与开闭原则（包括类图等），图形用户界面基础，集合框架（包括List接口及其实现类ArrayList、Map接口及其实现类HashMap），文件管理与输入输出流（包括File类、字符流、字节流、缓冲流等）以及线程</p><h2 id="二、注意地方"><a href="#二、注意地方" class="headerlink" title="二、注意地方"></a>二、注意地方</h2><h3 id="1-Integer类"><a href="#1-Integer类" class="headerlink" title="1.  Integer类"></a>1.  Integer类</h3><ul><li>integer.toBinaryString()输出二进制</li></ul><h3 id="2-Arrays类"><a href="#2-Arrays类" class="headerlink" title="2. Arrays类"></a>2. Arrays类</h3><ul><li><p>该类包含用于操作数组的各种方法（如排序和搜索）。 该类还包含一个静态工厂，可以将数组视为列表。</p></li><li><p>排序<br>public static void sort(double a[])<br> 含义：把参数a指定的double类型数组按照升序排序<br>public static void sort(double a[], int start, int end)<br> 含义：把参数a指定的double类型数组中索引start至end-1 的元素的值按照升序排序</p></li><li><p>二分法查找（要求数组已排序）<br>public static int binarySearch(double[] a, double number)<br> 含义：判断参数number指定的数是否在a指定的数组中，再返回该元素的索引，不在，返回一个负数。</p></li><li><p>复制<br>public static int[] copyOf(int[] original, int newLength)<br> 含义：把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组。<br>public static int[] copyOfRange(int[] original, int from, int to)<br> 含义：把参数original指定的数组中从索引from开始到 to-1的元素复制到一个新数组中，并返回这个新数组。</p><h3 id="3-enum"><a href="#3-enum" class="headerlink" title="3. enum"></a>3. enum</h3></li><li><p>定义<br>enum  Season {</p><p>   SPRING, SUMMER, AUTUMN, WINTER<br>}</p></li><li><p>用法<br>Season a ;<br>a.SPRING;</p><h3 id="4-pattern类"><a href="#4-pattern类" class="headerlink" title="4. pattern类"></a>4. pattern类</h3></li><li><p>正则表达式会用到<br>正则表达式的编译表示。<br>必须首先将正则表达式（指定为字符串）编译为此类的实例。 然后将所得的图案可以被用来创建一个Matcher对象可以匹配任意character sequences针对正则表达式。 执行匹配的所有状态都驻留在匹配器中，所以许多匹配者可以共享相同的模式。<br>因此，典型的调用序列<br>Pattern p = Pattern.compile(“a*b”);<br>Matcher m = p.matcher(“aaaaab”);<br>boolean b = m.matches();</p></li></ul><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><ol><li>长方形分为三块</li></ol><ul><li>类名（抽象类为斜体）</li><li>变量名</li><li>方法名</li><li>注意：public 为 + , 默认为缺省，protect为#，private为-；</li></ul><ol start="2"><li>关联 —&gt;</li><li>依赖 —-&gt;\</li><li>继承 —▷</li><li>实现接口 —-▷</li></ol><h3 id="6-JScrollPane"><a href="#6-JScrollPane" class="headerlink" title="6. JScrollPane"></a>6. JScrollPane</h3><p>提供轻量级组件的可滚动视图。 A JScrollPane管理视口，可选的垂直和水平滚动条以及可选的行和列标题视口。 您可以在How to Use Scroll Panes中找到面向任务的JScrollPane JScrollPane ， 这是Java教程中的一节。 请注意， JScrollPane不支持重量级组件。 </p><h3 id="7-Dimension"><a href="#7-Dimension" class="headerlink" title="7. Dimension"></a>7. Dimension</h3><p>Dimension类封装单个对象中组件的宽度和高度（以整数精度）。 该类与组件的某些属性相关联。 Component类和LayoutManager接口定义的几种方法返回一个Dimension对象。 </p><h3 id="3-三种布局"><a href="#3-三种布局" class="headerlink" title="3. 三种布局"></a>3. 三种布局</h3><ul><li>GridLayout-网格布局</li><li>BorderLayout-边框布局</li><li>FlowLayout-流式布局</li></ul><h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h3><h2 id="三、查缺补漏"><a href="#三、查缺补漏" class="headerlink" title="三、查缺补漏"></a>三、查缺补漏</h2><h3 id="1-移位运算"><a href="#1-移位运算" class="headerlink" title="1. 移位运算"></a>1. 移位运算</h3><ul><li>移位运算符</li></ul><p>** 二进制移位，移动一位相当于*2 || /2 **<br> &lt;&lt; （带符号左移） </p><blockquote><blockquote><p>（带符号右移） </p><blockquote><p>（无符号右移）<br> 列： D:\ideaWorkspace\review\src\displacement.java </p></blockquote></blockquote></blockquote><ul><li><strong>疑问： java输出负数二进制表现和机组不一样？</strong></li></ul><h3 id="2-数组的表示"><a href="#2-数组的表示" class="headerlink" title="2. 数组的表示"></a>2. 数组的表示</h3><ol><li>定义、</li></ol><ul><li>int a[]; // 不推荐</li><li>int [] a;</li></ul><ol start="2"><li>初始化</li></ol><ul><li>int a[] = new int[x];</li><li>int a[] = new int[]{1,2,3,4};</li><li>int a[] = {1,2,3,4}</li></ul><p>** 3. 注意：java不允许在声明数组中的方括号内指定数组长度。**</p><h3 id="3-修饰符表示范围"><a href="#3-修饰符表示范围" class="headerlink" title="3. 修饰符表示范围"></a>3. 修饰符表示范围</h3><table><thead><tr><th>修饰符</th><th>访问位置</th></tr></thead><tbody><tr><td>private</td><td>该类</td></tr><tr><td>默认</td><td>同一个包</td></tr><tr><td>protect</td><td>同一个项目</td></tr><tr><td>public</td><td>任何位置</td></tr></tbody></table><h3 id="4-抽象和接口的区别"><a href="#4-抽象和接口的区别" class="headerlink" title="4. 抽象和接口的区别"></a>4. 抽象和接口的区别</h3><ol><li>抽象</li></ol><ul><li>abstract方法没有方法体</li></ul><ol start="2"><li>接口</li></ol><ul><li>只能用public 和 空缺</li><li>默认为public 可以不写public</li></ul><p>** 接口规定类做什么，抽象类增加代码复用性**<br><em>见CSDN收藏</em></p><h3 id="5-Lambda表达式"><a href="#5-Lambda表达式" class="headerlink" title="5 . Lambda表达式"></a>5 . Lambda表达式</h3><ol><li>定义：Lambda表达式是一个匿名函数，即没有函数名的函数</li><li>表现形式：（参数/无参）-&gt; {多行语句}；</li><li>用法：一般用于匿名内部类，有单个方法。</li></ol><h3 id="6-输入输出流，缓冲流"><a href="#6-输入输出流，缓冲流" class="headerlink" title="6. 输入输出流，缓冲流"></a>6. 输入输出流，缓冲流</h3><ol><li>字符流</li></ol><ul><li>FileWriter</li><li>FileReader</li><li>注意方法：<br>fr.read() 读到末尾返回-1</li></ul><ol start="2"><li>字节流</li></ol><ul><li>FileInputStream</li><li>FileoutputStream</li></ul><ol start="3"><li>缓冲流</li></ol><ul><li>BufferedWriter</li><li>BufferedReader</li><li><em>创建的时候依赖与其他流 列： bf = new BufferedReader(fr)</em></li><li>注意的方法：<br>bw.readLine() 读一行  <em>不能写成 .read() , 为读一个字符</em>  //返回String<br>bw.newLine() 写一行行分隔符</li></ul><p>** 最后都需要关闭流（.close(）)    缓冲流要在文件流之前关闭**</p><h3 id="7-集合框架"><a href="#7-集合框架" class="headerlink" title="7. 集合框架"></a>7. 集合框架</h3><ul><li>迭代器 — 重点map</li></ul><ol><li>迭代器输出map的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; itervalue = map.values().iterator();</span><br><span class="line">while(itervalue.hasNext()) &#123;</span><br><span class="line">Sout(itervalue.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器输出map键-值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer,Student&gt;&gt; iterEntry = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterEntry.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer,Student&gt; entry =       (Map.Entry&lt;Integer,Student&gt;)iterEntry.next();  <span class="comment">//创造具体对象 类似于 new</span></span><br><span class="line">sout(iterEntry.getKey() + <span class="string">&quot;&lt;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-String-split"><a href="#8-String-split" class="headerlink" title="8. String split"></a>8. String split</h3><ul><li>将此字符串分割为给定的 regular expression的匹配。 </li><li>列：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;a-b-c-d&quot;;</span><br><span class="line">sout(s.split(-));</span><br><span class="line">结果： ab  c  d</span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title=". 正则表达式"></a>. 正则表达式</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习笔记</title>
      <link href="/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA学习笔记"><a href="#JAVA学习笔记" class="headerlink" title="JAVA学习笔记"></a>JAVA学习笔记</h1><h2 id="Day01-2021-8-8"><a href="#Day01-2021-8-8" class="headerlink" title="Day01 2021/8/8"></a>Day01 2021/8/8</h2><h1 id="一、注意"><a href="#一、注意" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>布尔常量是可以输出的</li><li>null不可以输出<h1 id="二、错误总结"><a href="#二、错误总结" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>float f=13.14;<pre><code> System.out.println(&quot;f&quot;)；错误</code></pre> 应该(f);<h2 id="Day02-2021-8-9"><a href="#Day02-2021-8-9" class="headerlink" title="Day02 2021/8/9"></a>Day02 2021/8/9</h2><h1 id="一、注意-1"><a href="#一、注意-1" class="headerlink" title="一、注意"></a>一、注意</h1></li><li>类型转换可以是从小到大，强制类型转换是从大转小（不建议使用，有数据丢失）</li><li><pre><code>    System.out.println(5.2 / a);//可以得到小数</code></pre></li><li>‘0’ Asics为48 ‘0–9’连续</li><li>算术表达式中包&lt;含多个数据类型&gt;的值的时候，整个算术表达式的类型会自动提升。</li><li><pre><code> System.out.println(&quot;黑马&quot; + 6 + 66); ——黑马666 System.out.println(1 + 99 + &quot;年黑马&quot;);———100黑马 总结： 从左到右运算</code></pre></li><li>+=包含了强制类型转换—(不建议)<br> short s=10;<br> s += 20; 正确        等同于s = (short)(s + 20)<br> s = s + 20; 错误 </li><li>b = a++; a值先给b，再++。一般单独使用++；</li><li>异或^ 相同为T,不同为F</li><li>短路与|| 左边为真右边不执行<br> 短路或&amp;&amp; 左边为假右边不执行<h1 id="二、错误总结-1"><a href="#二、错误总结-1" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>c=”A”,为字符串（String),  c=’A’，为单个字符；</li></ol><h2 id="Day03-2021-8-10"><a href="#Day03-2021-8-10" class="headerlink" title="Day03 2021/8/10"></a>Day03 2021/8/10</h2><h1 id="一、注意-2"><a href="#一、注意-2" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>测试数据：选择正确数据、边界数据、错误数据。</li><li>for循环里的循环变量，出了循环不可使用。while循环里的变量，全局都可以使用。</li><li>for( ; ; )为for的死循环    ctrl+c可以结束循环</li></ol><h2 id="Day04-2021-8-11"><a href="#Day04-2021-8-11" class="headerlink" title="Day04 2021/8/11"></a>Day04 2021/8/11</h2><h1 id="一、注意-3"><a href="#一、注意-3" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>反复练习idea操作</li></ol><h1 id="二、错误总结-2"><a href="#二、错误总结-2" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>idea中一旦选定文件储存区域，不能对文件进行重命名。</li></ol><h1 id="idea里的快捷键"><a href="#idea里的快捷键" class="headerlink" title="idea里的快捷键"></a>idea里的快捷键</h1><ol><li>快速生成mian() psvm,</li><li>快速生成输出 sout</li><li>内容辅助 ctrl + Alt + space</li><li>ctrl + Alt + l 修改代码标准格式</li><li>ctrl + Alt + v 代码自动补全</li></ol><h2 id="Day05-2021-8-12"><a href="#Day05-2021-8-12" class="headerlink" title="Day05 2021/8/12"></a>Day05 2021/8/12</h2><h1 id="一、注意-4"><a href="#一、注意-4" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>方法重载</li><li>输出语句</li><li>从问题中提炼数据，从数据中寻找规律，从规律中程序化。<h1 id="二、错误总结-3"><a href="#二、错误总结-3" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>该错误要一改都改，记得改了同样出现的地方。</li></ol><h2 id="Day06-2021-8-13"><a href="#Day06-2021-8-13" class="headerlink" title="Day06 2021/8/13"></a>Day06 2021/8/13</h2><h1 id="一、注意-5"><a href="#一、注意-5" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>private 修饰成员变量</li><li>this关键字，加载变量前，解决局部变量隐藏成员变量</li><li>构造方法，在类中 public Student() {};</li><li>构造方法就相当于方法   函数；</li></ol><h1 id="二、错误总结-4"><a href="#二、错误总结-4" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>给字符串（String）赋值要加引号，单引号、双引号；</li></ol><h2 id="Day07-2021-8-14"><a href="#Day07-2021-8-14" class="headerlink" title="Day07 2021/8/14"></a>Day07 2021/8/14</h2><h1 id="一-注意"><a href="#一-注意" class="headerlink" title="一,注意"></a>一,注意</h1><h1 id="二-错误总结"><a href="#二-错误总结" class="headerlink" title="二,错误总结"></a>二,错误总结</h1><ol><li>System.out.println(“输入的数据是：” + line);    正确—-不能写成System.out.println(“输入的数据是： + line”);</li></ol><h2 id="Day08-2021-8-15"><a href="#Day08-2021-8-15" class="headerlink" title="Day08 2021/8/15"></a>Day08 2021/8/15</h2><h1 id="一、注意-6"><a href="#一、注意-6" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li><code>[用==作比较：  基本类型：比较的是数据值是否相同      应用类型：比较的是地址值是否相同]</code>()</li><li><code>比较字符串用方法：.equals()    public boolen equals(Object and Obeject);    s1.equals(s2)</code></li><li>获取字符串中单个字符 .charAt();    </li><li>获取字符串的长度 .length();</li><li>String是可变的，StringBuilde是不可变的。</li><li>StringBulider中append添加数据并返回数据本身    reverse反转<br> B-&gt;S转换String s = sb.toString();<br> S-&gt;B转换StringBuilder sb = new StringBuilder(s);</li><li>ArrayList方法：<br> 删除–返回是否成功<br> array.remove(“world”);<br> 删除指定位置–返回别删除元素<br> array.remove(1);<br> //修改指定位置索引，返回被修改元素<br> System.out.println(array.set(1,”nima”));<pre><code> //返回索引处的元素 System.out.println(array.get(1));   //返回集合中元素的个数 System.out.println(array.size()); //输出集合 System.out.println(array); //添加 add</code></pre></li></ol><h1 id="二、错误总结-5"><a href="#二、错误总结-5" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>一般数组或者字符串的遍历用for()循环</li><li>定义变量必须初始化(与C语言不同)</li><li>字符串可以定义byte {97}输出字符，s.charAt(a) &gt;= 97正确</li><li>数字不带引号，字符串带引号；</li><li>一开始写不能忘记main方法！！！<h1 id="Day09-8-18"><a href="#Day09-8-18" class="headerlink" title="Day09/8/18"></a>Day09/8/18</h1></li></ol><h2 id="一-注意-1"><a href="#一-注意-1" class="headerlink" title="一.注意"></a>一.注意</h2><ol><li><p>快捷键 alt + insert    根据自己的需要进行选择。</p></li><li><h2 id="字符串比较不能用-比较！！！！用equal！！！"><a href="#字符串比较不能用-比较！！！！用equal！！！" class="headerlink" title="字符串比较不能用 == 比较！！！！用equal！！！"></a>字符串比较不能用 == 比较！！！！用equal！！！</h2></li><li><h2 id="多想！！多尝试！！把问题全面化，简单化！！一定可以！"><a href="#多想！！多尝试！！把问题全面化，简单化！！一定可以！" class="headerlink" title="多想！！多尝试！！把问题全面化，简单化！！一定可以！"></a>多想！！多尝试！！把问题全面化，简单化！！一定可以！</h2></li></ol><h2 id="二、错误总结-6"><a href="#二、错误总结-6" class="headerlink" title="二、错误总结"></a>二、错误总结</h2><ol><li>System.exit(0);   退出程序.</li><li>switch用String的好处，输入出错，程序不会报错，还可以继续运行下去，直到输入正确的选择。</li><li>输出特殊含义的方法   在sout里不能加引号。</li><li>用ArrayLiss中数据时，必学先取出对象，再调用对象的方法。</li><li>多思考！！！！！摆脱惯性思维！！！！！！</li><li>while 和 for里定义的变量外界不能用，但在外界定义，在里面赋值操作，外界同样改变！</li></ol><h1 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h1><h2 id="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"><a href="#程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！" class="headerlink" title="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"></a>程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！</h2><h2 id="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"><a href="#相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！" class="headerlink" title="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"></a>相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！</h2><h2 id="d-StudentManger-delete-update-Student-里对学号不存在的判断"><a href="#d-StudentManger-delete-update-Student-里对学号不存在的判断" class="headerlink" title="d://StudentManger    delete\update Student 里对学号不存在的判断"></a>d://StudentManger    delete\update Student 里对学号不存在的判断</h2><h2 id="从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！"><a href="#从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！" class="headerlink" title="从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！"></a>从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！</h2><h1 id="Day10-09-11"><a href="#Day10-09-11" class="headerlink" title="Day10/09/11"></a>Day10/09/11</h1><h2 id="一、注意-7"><a href="#一、注意-7" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>继承格式 public class  zi extends fu() {};</li><li>构造方法和成员方法：<br> 1.构造方法 构造方法作用概述 给对象的数据进行初始化 构造方法格式 方法名与类名相同 没有返回值类型,连void都没有 没有具体的返回值 构造方法注意事项 如果你不提供构造方法,系统会给出默认构造方法 如果你…<br> 2.成员方法 成员方法作用概述 表示对象所具有的功能(和行为)。 成员方法格式 有返回类型,可以为void类型,也可以是基本数据类型.</li><li>继承中变量 、方法的访问特点：<br> 先方法，再成员变量，再父类<br> 想访问成员用this,想访问父类用super</li><li>@override<br>@Override这个标签有什么用呢。。。。。。<br>其实我也是比较迷茫，查了一下，三个作用吧</li><li>可以给你当作注释用，感觉这个也不能说明什么，注释也没什么用。</li><li>可以告诉读你代码的人，这是对它父类方法的重写，其实很多代码规范没有为什么，规范就是规范，代码的可读性还是很重要的。</li><li>编译器可以给你验证@Override下面的方法名称是否是你父类中所有的，如果没有就会报错。</li><li>访问权限：public &gt; 默认 &gt; privata</li><li>类只支持单继承，不支持多继承，但支持多层继承。</li></ol><h1 id="Day11-09-12"><a href="#Day11-09-12" class="headerlink" title="Day11/09/12"></a>Day11/09/12</h1><h2 id="一、注意-8"><a href="#一、注意-8" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>java se :标准版 用于开发桌面应用</li><li>java ee: 企业版</li><li>java me: 微型</li></ol><h1 id="Day11-09-26"><a href="#Day11-09-26" class="headerlink" title="Day11/09/26"></a>Day11/09/26</h1><h2 id="一、注意-9"><a href="#一、注意-9" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>导包，文件直接创建，cmd      java d . Hello.java</li><li>修饰符 （publick) （protected)     (默认)    (private)</li><li>状态修饰符<br> final 最终，修饰成员 1. 方法，2. 成员变量，3. 类，4. 局部变量，5. 引用变量（如 final Student s = new Student;)。<ol><li>最终方法，不能被重写；</li><li>变量为常量，不能再次被赋值；</li><li>最终类，不能被继承。</li><li>数据值不能变；</li><li>地址值不能变，但是地址值里的内容可以变。</li></ol><hr> static 静态，可以修饰成员方法，成员变量。<ol><li>特点： 别类的所有对象共享；——–也是判断是否使用静态关键字的条件。</li><li>可以使用对象名调用，也可以使用类名调用。&lt;推荐类名调用&gt;</li><li>静态成员方法只能访问静态成员。</li><li>非静态都可以访问。</li><li>main通常为静态 所以，类下面的方法一般也为静态。<h1 id="Day12-2021-9-29"><a href="#Day12-2021-9-29" class="headerlink" title="Day12/2021/9/29"></a>Day12/2021/9/29</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="一、-多态中成员访问特点"><a href="#一、-多态中成员访问特点" class="headerlink" title="一、 多态中成员访问特点"></a>一、 <strong>多态中成员访问特点</strong></h3></li></ol></li><li></li></ol><p>![e043f945ba7d7bd37ad0329bbe9bc4a](C:\Users\23694\AppData\Local\Temp\WeChat Files\e043f945ba7d7bd37ad0329bbe9bc4a.png)<br>2. **多态的好处与弊端</p><p>![df065b619113d744a14b7e889e6837e](C:\Users\23694\AppData\Local\Temp\WeChat Files\df065b619113d744a14b7e889e6837e.png)</p><ol start="3"><li><p>**多态的转型<br>//多态</p><pre><code> Arimal a = new Cat(); //1.从子到父，父类引用指向子类对象、向上转型 a.eat();//2.从父到子，向下转型，父类引用转为子类对象 Cat c = (Cat)a; c.playGame(); //逆着看 </code></pre><h1 id="Day13-2021-10-06"><a href="#Day13-2021-10-06" class="headerlink" title="Day13/2021/10/06"></a>Day13/2021/10/06</h1><h2 id="抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png"><a href="#抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png" class="headerlink" title="抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)"></a>抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)</h2><h3 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h3></li></ol><h1 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h1><ol><li>![9ddca1064128fcc4f0de5b42eb43295](C:\Users\23694\AppData\Local\Temp\WeChat Files\9ddca1064128fcc4f0de5b42eb43295.png)String 定义的变量赋值要加 ”“；</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="一、接口的特点"><a href="#一、接口的特点" class="headerlink" title="一、接口的特点"></a>一、接口的特点</h2><ol><li>用关键字Interface修饰；</li><li>类实现接口用implement</li><li>接口不能实例化<br> *可用多态方式，通过实现对象实例化，这叫接口多态。</li><li><strong>多态的形式<br> 具体类多态、抽象类多态、接口多态</strong></li><li><strong>多态的前提<br> 有继承或者实现关系； 有方法重写；有父类的（接口/类)引用指向(子/实现)类对象</strong><h2 id="二、接口的成员特点"><a href="#二、接口的成员特点" class="headerlink" title="二、接口的成员特点"></a>二、接口的成员特点</h2></li><li></li></ol><p>![8b1956872eda32d7978c71682dcc980](C:\Users\23694\AppData\Local\Temp\WeChat Files\8b1956872eda32d7978c71682dcc980.png)<br>2. 接口不可以实列化** 当有的方参数为接口时，调用的是接口的implement。测试类中也要用堕胎的方式创建接口**</p><h1 id="Day14-2021-10-24"><a href="#Day14-2021-10-24" class="headerlink" title="Day14/2021/10/24"></a>Day14/2021/10/24</h1><h1 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h1><p>*练习文件所在位置D:\ideaWorkspace-practice\src\：</p><h2 id="1-1-访问特点"><a href="#1-1-访问特点" class="headerlink" title="1. 1 访问特点"></a>1. 1 访问特点</h2><ol><li>内部类可以直接反问外部类的成员、包括私有</li><li>外部类要想访问内部类。必需创建对象</li></ol><h3 id="1-1-1分类"><a href="#1-1-1分类" class="headerlink" title="1.1.1分类"></a>1.1.1分类</h3><blockquote><blockquote><p>成员内部类<br>局部内部类</p></blockquote></blockquote><h2 id="1-2成员内部类"><a href="#1-2成员内部类" class="headerlink" title="1.2成员内部类"></a>1.2成员内部类</h2><h3 id="1-2-1成员内部类如何创建使用"><a href="#1-2-1成员内部类如何创建使用" class="headerlink" title="1.2.1成员内部类如何创建使用"></a>1.2.1成员内部类如何创建使用</h3><blockquote><blockquote><p>格式  ： 外部类名.内部类名 对象名 = 外部类对象.内部类对象<br>范列  ：        Outher.Inner i = new Outher().new Inner();</p><blockquote><p>注意：还有一种是在外部类方法中创建内部类对象，在测试类中直接调用该方法，实现成员内部类的创建和使用。</p></blockquote></blockquote></blockquote><h2 id="1-3局部内部类"><a href="#1-3局部内部类" class="headerlink" title="1.3局部内部类"></a>1.3局部内部类</h2><h3 id="1-3-1定义"><a href="#1-3-1定义" class="headerlink" title="1.3.1定义"></a>1.3.1定义</h3><blockquote><blockquote><p>在方法中定义的类。外界无法显示，需要在方法内部创建对象并使用该类，可以直接访问外部类的成员，也可以访问方法内的局部变量；</p></blockquote></blockquote><h2 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h2><p><em>局部内部类的一种特俗形式</em><br><strong>前提</strong> ： 存在一个类或者接口，这里类可以是具体类也可以是抽象类<br><strong>本质</strong> :   是一个继承了该类或者实现了该接口的子类^匿名对象^</p><h3 id="1-4-1-格式"><a href="#1-4-1-格式" class="headerlink" title="1.4.1 格式"></a>1.4.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名() &#123;  </span><br><span class="line">重写方法；^说明继承了前面的类或者说实现了一个接口^</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>最后的分号不能忘</strong></p><h3 id="1-4-2-调用"><a href="#1-4-2-调用" class="headerlink" title="1.4.2 调用"></a>1.4.2 调用</h3><blockquote><blockquote><p>可以利用多态的方法赋值给类或者接口 ，对类或者接口进行方法调用。</p></blockquote></blockquote><h2 id="1-5-匿名内部类在开发中的作用"><a href="#1-5-匿名内部类在开发中的作用" class="headerlink" title="1.5 匿名内部类在开发中的作用"></a>1.5 匿名内部类在开发中的作用</h2><h3 id="1-5-1案例"><a href="#1-5-1案例" class="headerlink" title="1.5.1案例"></a>1.5.1案例</h3><p> //使用匿名内部类，可以使不用创建具体的猫对象<br>        jo.method(new Jumpping() {<br>            @Override<br>            public void jump() {<br>                System.out.println(“狗会跳”);<br>            }<br>        });</p><h3 id="一、注意-10"><a href="#一、注意-10" class="headerlink" title="一、注意"></a>一、注意</h3><ol><li><strong>通用</strong> 类里不能直接输出（sout),必须创建方法;</li><li><strong>通用</strong>所有可以实现的方法颜色都会发生改变；</li></ol><h3 id="二、错误总结-7"><a href="#二、错误总结-7" class="headerlink" title="二、错误总结"></a>二、错误总结</h3><h1 id="day15-2021-10-26"><a href="#day15-2021-10-26" class="headerlink" title="day15/2021/10/26"></a>day15/2021/10/26</h1><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h1 id="1、Math"><a href="#1、Math" class="headerlink" title="1、Math"></a>1、Math</h1><h2 id="1-1-Math类概述"><a href="#1-1-Math类概述" class="headerlink" title="1.1 Math类概述"></a>1.1 Math类概述</h2><blockquote><blockquote><p>基本数学方法</p></blockquote></blockquote><h2 id="1-2-Math类的常用方法"><a href="#1-2-Math类的常用方法" class="headerlink" title="1.2 Math类的常用方法"></a>1.2 Math类的常用方法</h2><ol><li>abs(int )——绝对值</li><li>ceil(double )——大于或等于参数的最小double值</li><li>floor(double )——小与或等于参数的最大double值</li><li>round(float )——四舍五入返回最接近参数的int</li><li>max(int )——较大值</li><li>min(int )——较小值</li><li>pow(double a, double b)——a的b次幂</li><li>random( )——返回为double的正直，[0.0,1.0)    <em>（int)random())可强转为int</em></li></ol><h1 id="2、System"><a href="#2、System" class="headerlink" title="2、System"></a>2、System</h1><h2 id="2-1-System类概述"><a href="#2-1-System类概述" class="headerlink" title="2.1 System类概述"></a>2.1 System类概述</h2><p><strong>包含几个有用的类字段和方法，它不能被实例化。</strong></p><h2 id="2-2-System类的常用方法"><a href="#2-2-System类的常用方法" class="headerlink" title="2.2 System类的常用方法"></a>2.2 System类的常用方法</h2><ol><li>exit(0)——终止当前运行的java虚拟机，非零表示异常终止</li><li>currentTimeMillis()——返回当前时间（以毫秒为单位）<br> *可以用来计算for循环耗时<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long strat = System.currentTimeMillis();</span><br><span class="line">for();</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">sout(&quot;time&quot; = strat - long);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="3、Object"><a href="#3、Object" class="headerlink" title="3、Object"></a>3、Object</h1><h2 id="3-1-Object类的概述"><a href="#3-1-Object类的概述" class="headerlink" title="3.1 Object类的概述"></a>3.1 Object类的概述</h2><p>** Class Object是类Object结构的根。 每个班都有Object作为超类。 所有对象（包括数组）都实现了这个类的方法。**</p><h3 id="3-1-1构造方法"><a href="#3-1-1构造方法" class="headerlink" title="3.1.1构造方法"></a>3.1.1构造方法</h3><p><strong>public Object();</strong></p><h2 id="3-2-Object类的常用方法"><a href="#3-2-Object类的常用方法" class="headerlink" title="3.2 Object类的常用方法"></a>3.2 Object类的常用方法</h2><ol><li>toString()——输出对象地址<em>建议所有子类都重写</em></li><li>equals()——</li></ol><h1 id="day16-2021-11-13"><a href="#day16-2021-11-13" class="headerlink" title="day16/2021/11/13"></a>day16/2021/11/13</h1><p><strong>==一些基础总结==</strong></p><h2 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h2><ol><li>JCheckBox 复选框 getText()</li><li>JComboBox 下拉列表 .getSelectedItem().toString()</li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>final abstract 不能同时出现</li><li>接口里也可以有抽象方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">public interface Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //A</span><br><span class="line"></span><br><span class="line">    public int x = 0;          //B </span><br><span class="line"></span><br><span class="line">    static int y = 0;          //C</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Cat implements Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //D</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  abstract void cry(); </span><br><span class="line">B. public int x = 0;</span><br><span class="line">C.  static int y = 0; </span><br><span class="line">D. abstract void cry(); </span><br><span class="line">我的答案: D正确答案: D</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>抽象方法必须实现，接口不一定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">interface Com &#123;</span><br><span class="line"></span><br><span class="line">    int MAX = 100;  //A</span><br><span class="line"></span><br><span class="line">    void f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal implements Com &#123;</span><br><span class="line"></span><br><span class="line">    int MIN ;      //B</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    public void f() &#123;  </span><br><span class="line"></span><br><span class="line">       MIN = 10;     //C</span><br><span class="line"></span><br><span class="line">       MAX = 200;    //D</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  int MAX = 100;</span><br><span class="line">B.  int MIN ; </span><br><span class="line">C. MIN = 10; </span><br><span class="line">D. MAX = 200; </span><br><span class="line">我的答案: D正确答案: D</span><br></pre></td></tr></table></figure></li><li>接口方法只能用public 、 默认<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口中的方法也可以用private或protected修饰。</span><br><span class="line">A. 对</span><br><span class="line">B. 错</span><br><span class="line">我的答案: 错正确答案: 错</span><br></pre></td></tr></table></figure><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2></li><li>(判断题)子类在方法重写时，不可以把父类的实例方法重写为类（static）方法，也不可以把父类的类（static）方法重写为实例方法。</li><li>子类继承父类的构造方法。<br>我的答案: 错正确答案: 错<br>答案解析：子类有子类的构造方法，父类有父类的构造方法，子类是不会继承父类的构造函数的，只是必须调用</li><li>** 继承普通父类可以方法重写，继承继承抽象类不可以。**</li></ol><p><strong>== 注 ==</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. (单选题)</span><br><span class="line">下列哪个代码（A，B，C，D）放入程序中标注的【代码】处将导致编译错误？</span><br><span class="line"></span><br><span class="line">class A &#123; </span><br><span class="line"></span><br><span class="line">   public float getNum() &#123;</span><br><span class="line"></span><br><span class="line">       return 3.0f;</span><br><span class="line"></span><br><span class="line">   &#125;     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class B extends A &#123; </span><br><span class="line"></span><br><span class="line">      【代码】</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A. public float getNum()&#123;return 4.0f;&#125; </span><br><span class="line">B.  public void getNum()&#123; &#125;   **√**</span><br><span class="line">C.  public void getNum(double d)&#123; &#125; </span><br><span class="line">D.  public double getNum(float d)&#123;return 4.0d;&#125;</span><br><span class="line"></span><br><span class="line">可以重写方法如改变（），不可以改变返回值类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="day17-2021-11-17"><a href="#day17-2021-11-17" class="headerlink" title="day17/2021/11/17"></a>day17/2021/11/17</h1><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\V{W{LYR]J}PIRL6CIA_NO33.png"></p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><h3 id="1-2-集合类结构体"><a href="#1-2-集合类结构体" class="headerlink" title="1,2 集合类结构体"></a>1,2 集合类结构体</h3><p>** 集合分为Collection和Map**<br>** Cpllection 分为list \ set  **</p><h3 id="1-3Collection"><a href="#1-3Collection" class="headerlink" title="1.3Collection"></a>1.3Collection</h3><h4 id="1-3-1创建Collection集合的对象"><a href="#1-3-1创建Collection集合的对象" class="headerlink" title="1.3.1创建Collection集合的对象"></a>1.3.1创建Collection集合的对象</h4><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul><h3 id="1-4-Collection的常用方法"><a href="#1-4-Collection的常用方法" class="headerlink" title="1.4 Collection的常用方法"></a>1.4 Collection的常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\M(]U7X8VZ3QLJGM]Z4RI%JW.png"></p><h3 id="1-5Collection遍历"><a href="#1-5Collection遍历" class="headerlink" title="1.5Collection遍历"></a>1.5Collection遍历</h3><p><strong>iterator 迭代器,集合专用遍历方式</strong><br> iterator<E> iterator(): 返回集合中元素的迭代器，通过iterator()方法得到 <strong>==        Iterator<String> it = list.iterator();==</strong></p><ul><li>依赖与集合存在</li></ul><p><strong>常用方法</strong></p><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构[9Z(}TRZWC%_UI5)C@QL~5B.png"></p><h3 id="1-6集合的使用步骤"><a href="#1-6集合的使用步骤" class="headerlink" title="1.6集合的使用步骤"></a>1.6集合的使用步骤</h3><ol><li>创建集合对象</li><li>添加元素</li><li>遍历集合（三总遍历方式）<blockquote><p>利用size（）和for循环<br>增强for循环<br>迭代器iterator</p></blockquote></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>== 如何把多个对象一起加入集合==</strong><br><strong>== hashCode==</strong></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>AlT + 7 打开一个窗口，可以看到类的所有信息</strong><br>**ctrl + alt + v 、补全代码</p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><h3 id="2-1-List集合概述和特点"><a href="#2-1-List集合概述和特点" class="headerlink" title="2.1 List集合概述和特点"></a>2.1 List集合概述和特点</h3><ul><li>概述：</li><li>有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 </li><li>与Set集合不同，列表允许重复元素</li><li>特点：</li><li>有序：存储和取出的元素顺序一致</li><li>可重复：存储的元素可重复<h3 id="2-2-List集合特有方法"><a href="#2-2-List集合特有方法" class="headerlink" title="2.2 List集合特有方法"></a>2.2 List集合特有方法</h3></li></ul><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\list特有方法.png"></p><h3 id="2-3并发修改异常"><a href="#2-3并发修改异常" class="headerlink" title="2.3并发修改异常"></a>2.3并发修改异常</h3><ul><li>ConcurrentModificationException</li><li>产生原因：</li><li>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致。</li></ul><h3 id="2-4Listlterator"><a href="#2-4Listlterator" class="headerlink" title="2.4Listlterator"></a>2.4Listlterator</h3><blockquote><p>列表迭代器</p></blockquote><ul><li><p>集合特有的迭代器</p></li><li><p>用于允许程序员沿任一方向遍历列表的列表的迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</p></li><li><p>常用方法：</p></li><li><p>next（）、hasNext()、previous（）、hasPrevious（）</p></li><li><p>addE e() ** 不会出现并发异常##</p></li></ul><h3 id="2-5-增强for循环"><a href="#2-5-增强for循环" class="headerlink" title="2.5 增强for循环"></a>2.5 增强for循环</h3><blockquote><p>简化数组和Collection集合的遍历<br>实际上为iterator迭代器</p></blockquote><ul><li>格式</li><li>for(元素类型 变量名 ：数组或集合名 ) { 变量既为该元素}</li></ul><h3 id="2-6数据结构"><a href="#2-6数据结构" class="headerlink" title="2.6数据结构"></a>2.6数据结构</h3><h3 id="2-7-常见数据结构"><a href="#2-7-常见数据结构" class="headerlink" title="2.7 常见数据结构"></a>2.7 常见数据结构</h3><h3 id="2-8-linkedList常用方法"><a href="#2-8-linkedList常用方法" class="headerlink" title="2.8 linkedList常用方法"></a>2.8 linkedList常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\852.png"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>//调用迭代器方法 不是new一个迭代器对象，不用new<pre><code> ListIterator&lt;String&gt; lit =  list.listIterator();</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 黑马程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程单词积累</title>
      <link href="/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/"/>
      <url>/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="编程单词"><a href="#编程单词" class="headerlink" title="编程单词"></a>编程单词</h1><ol><li>object 对象</li><li>geometric 几何图形</li><li>circle 圆</li><li>rectangle 长方体</li><li>radius 半径</li><li>Perimeter周长</li><li>Diameter 直径</li><li>introduce 介绍</li><li>query 查询</li><li>coach 教练</li><li>alter 改变</li><li>column 柱</li><li>method方法</li><li>文件file</li><li>领域field</li><li>regex 正则表达式</li><li>valid 有效的</li><li>module 单元、模块</li><li>title 标题、称谓</li><li>untitled 无标题的</li><li>until 直到</li><li>configured 安置、配置</li><li>kit 配套元件</li><li>SDK(Software Development Kit)</li><li>API(Application Programming Interface) 应用编程接口</li><li>appear 显得、看来</li><li>appearance 外貌、外观</li><li>plugins 插件</li><li>version 版本</li><li>advance 前进、预先的</li><li>advanced 高级的</li><li>contrast 对比</li><li>theme 主题</li><li>mouse 老鼠、鼠标</li><li>ambiguous 模棱两可的</li><li>post 邮递、投递</li><li>postman 邮局</li><li>scheme 计划、方案</li><li>block 块</li><li>template 样板</li><li>deployed 部署、调动</li><li>compiler 编译程序、汇编者</li><li>automatically 自动的、机械的</li><li>binary 二进制的</li><li>displacement 移位</li><li>fill 填满</li><li>pattern 图案</li><li>hard adj-坚固的，adv-努力地</li><li>scroll n-纸卷，v-滚动</li><li>dimension n-维，尺寸 adj-切成特定尺寸的</li><li>parse 作语法分析</li><li>judge 判断</li><li>Frame 窗体</li><li>farm 农场</li><li>expression 表示</li><li>stream n-流，v-流动</li><li>interrupt 打断</li><li>trace vt-查出，n-痕迹</li><li>dialog 对话框，对话</li><li>suspend 暂停</li><li>tempory 临时</li><li>MVC （Model-View-Controller)</li><li>organizations 社团</li><li>component 组成成分</li><li>override 推翻</li><li>current 现在的</li><li>sort 分类，排序</li><li>commons 平民、公地</li><li>stereo 立体声</li><li>podcast 博客</li><li>social 社会的</li><li>customer 顾客</li><li>address 地址</li><li>delivery 派送、分发</li><li>State 状态</li><li>query 查询</li><li>info 信息</li><li>prefer 更喜欢</li><li>validate 验证、确认</li><li>register 注册</li><li>foreground 前景、强调</li><li>check 检测</li><li>edit 编辑</li><li>preferred 首选</li><li>dimension 维，尺寸</li><li>internal 内部的</li><li>validate 验证</li><li>column 列</li><li>row 行</li><li>truncate 截断、adj.被删节的</li><li>restore 恢复</li><li>compression 压缩</li><li>canvas 帆布、油画</li><li>handler 处理器</li><li>warning 警告</li><li>native 出生地的</li><li>assets 资产</li><li>res 物、事件</li><li>blank 空白的</li><li>black 黑的</li><li>handle 把手、处理</li><li>kit 配套元件、装备</li><li>observe 看到、注意到</li><li>gap 缺口、缝隙</li><li>picture 相片、图片、想象</li><li>stroke 打一下、轻抚</li><li>round 圆形的</li><li>miter 斜接</li><li>adapter 适配器</li><li>press v按，n-记者、报刊</li><li>release 释放</li><li>instanceof 运算符，关键字</li><li>performed 做、执行、表演</li><li>internal 内部的</li><li>dispose 处置</li><li>category 类别</li><li>deploy 部署</li><li>catch 接住</li><li>Catch you late  待会见</li><li>fatal 致命的</li><li>archives 档案</li><li>categoties 类别</li><li>tags 标签</li><li>host 主办</li><li>config 配置</li><li>branch 分枝</li><li>token 代币、装样子、令牌</li><li>archive 档案文件</li><li>shrink 收缩</li><li>envelope 信封</li><li>mailto 电子邮件</li><li>sticky 粘性的、告事帖</li><li>matter 事情、要紧</li><li>copyright 版权</li><li>license 许可证、许可</li><li>common 常用的、共有的</li><li><strong>footer 页脚</strong></li><li>since 自从、因为</li><li>custon 风俗、定做</li><li>storage 存储</li><li>configure 配置</li><li>plugin 插件</li><li>prefix 前缀</li><li>fancy v.设想、n.想象的事情、adj.花哨的</li><li>ensure 确保</li><li>cooperate 合作</li><li>compatibility 兼容性</li><li>npm Node Package Manager</li><li>asset 资产</li><li>secure 保护</li><li>license 许可证</li><li>appearance 外貌</li><li>wheel 轮、推</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
          <category> 单词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 单词积累 </tag>
            
            <tag> 编程单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day02-27-移除元素</title>
      <link href="/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>你不需要考虑数组中超出新长度后面的元素。</p><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>用一个for循环遍历数组，遇到相同的元素，从该位置开始，后面元素前移</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果:  nums[j] = nums[j+1];索引越界报错，假如j为最后一个元素，是没有j+1个元素的<h2 id="改错后"><a href="#改错后" class="headerlink" title="改错后"></a>改错后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != size-<span class="number">1</span>) &#123;</span><br><span class="line">                        nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nums[j] = <span class="number">101</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果： 加了对最后一个元素的判断还是不行。仔细想了想其实是，若有目标元素size就减小了，而我for循环里用的.length。 同时元素向前移动，i的值也应减小<h2 id="再次改进"><a href="#再次改进" class="headerlink" title="再次改进"></a>再次改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int size = nums.length;</span><br><span class="line">        for(int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if(nums[i] == val) &#123;</span><br><span class="line">                for(int j = i; j &lt; size; j++) &#123;</span><br><span class="line">                    if (j != size-1) &#123;</span><br><span class="line">                        nums[j] = nums[j+1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        nums[j] = 101;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果： 正确解答! 但是内存消耗和时间复杂度都太高</li></ul><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line"></span><br><span class="line">        // 快慢指针</span><br><span class="line">        int fastIndex = 0;</span><br><span class="line">        int slowIndex;</span><br><span class="line">        for (slowIndex = 0; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            if (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slowIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是参考别人的代码，实在妙。</li><li>思想：利用两个‘指针’一前一后对数组进行遍历。若前面’指针’遇到了目标元素，则后面指针没有值，若没有遇上，就等于前面’指针’的元素。</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>还是考虑不够周到</li><li>慢慢来吧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day01-7004-二分查找</title>
      <link href="/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>704.给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4    </span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1   </span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p>你可以假设 nums 中的所有元素是不重复的。</p></li><li><p>n 将在 [1, 10000]之间。</p></li><li><p>nums 的每个元素都将在 [-9999, 9999]之间。</p><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while(first &lt; last) &#123;</span><br><span class="line">            int mid = (first + last) / 2;</span><br><span class="line">            if(target &gt; nums[mid]) &#123;</span><br><span class="line">                first = first + 1;</span><br><span class="line">            &#125; else if(target &lt; nums[mid]) &#123;</span><br><span class="line">                last = last - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提示有部分测试解答错误，并且该答案只是将时间复杂度降到了O(n/2)。</p></li></ul><h2 id="第二次改进"><a href="#第二次改进" class="headerlink" title="第二次改进"></a>第二次改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次循环都使mid为最中间的数，成功的把时间复杂度降为O(log2(n)),并且测试通过</li></ul><h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><ul><li>在查看答案后发现忽略了目标数target的范围<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">     // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br><span class="line">        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>加入一个目标是范围判断可以有效避免程序做无用功。</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>还是考虑的太少，对算法不熟悉</li><li>要多练</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
