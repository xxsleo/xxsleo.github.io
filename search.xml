<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基本命令(1)</title>
      <link href="/2022/01/22/JavaWeb/Linux/Day01/"/>
      <url>/2022/01/22/JavaWeb/Linux/Day01/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux系统与设置命令"><a href="#Linux系统与设置命令" class="headerlink" title="Linux系统与设置命令"></a>Linux系统与设置命令</h2><h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><ol><li>创建用户：useradd (选项) 用户名</li><li>用户口令:   passwd –</li><li>修改用户：usermod –</li><li>删除用户：userdel –</li><li>退出当前用户：ctrl + d</li></ol><ul><li>输入useradd回车，即可显示选项</li></ul><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><ol><li>创建用户组：groupadd (选项) 用户组名</li><li>修改用户组：groupmod –</li><li>查询用户所属组：groups 用户名</li><li>删除用户组：groupdel 用户组名</li></ol><h3 id="管理用户组内成员"><a href="#管理用户组内成员" class="headerlink" title="管理用户组内成员"></a>管理用户组内成员</h3><p>语法：    gpasswd (选项) 组名</p><ul><li>gpasswd是Linux下的管理工具，用于将一个用户添加到组或者从组中删除。</li><li>-a 添加</li><li>-d 删除</li><li>-A 指定管理员</li><li>-M 指定组成员和-A用途相差不大</li><li>-r 删除密码</li><li>-R 限制用户登入组，只有组中的成员才可以用newgrp加入该组</li></ul><h3 id="日期管理"><a href="#日期管理" class="headerlink" title="日期管理"></a>日期管理</h3><p>语法： date [参数选项]<br><strong>参数选项：</strong></p><ul><li>-d&lt;字符串&gt; : 显示字符串所指的日期与时间。字符串前后必须加上双引号；</li><li>-s&lt;字符串&gt; : 根据字符串来设置日期与时间。字符串前后必须加上双引号；</li><li>-u：显示GMT;</li><li>–help : 在线帮助</li><li>– version ：显示版本信息</li></ul><h3 id="显示用户"><a href="#显示用户" class="headerlink" title="显示用户"></a>显示用户</h3><p>语法：logname [–help][–version]    显示登录账号的信息<br><strong>参数信息：</strong></p><ul><li>–help 在线帮助</li><li>–version 显示版本信息</li></ul><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>语法 ：su [参数选项] [USER]<br><strong>参数选项：</strong></p><ul><li>USER要变更的用户账号</li><li>-c 使用目标用户执行一条命令，而不进入 如： su -c ls root</li></ul><h3 id="id命令"><a href="#id命令" class="headerlink" title="id命令"></a>id命令</h3><p>语法： id [-g][–help][-version] [用户名称]    查看当前用户详细信息（用户id,群组，所属组）</p><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>语法：sudo [参数选项]    提高普通用户的操作权限</p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>语法：top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]    实时显示process的动态<br><strong>各进程（任务）的状态监控属性解释说明：</strong><br>PID — 进程id<br>USER — 进程所有者<br>PR — 进程优先级<br>NI — nice值。负值表示高优先级，正值表示低优先级<br>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>SHR — 共享内存大小，单位kb<br>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU — 上次更新到现在的CPU时间占用百分比<br>%MEM — 进程使用的物理内存百分比<br>TIME+ — 进程使用的CPU时间总计，单位1/100秒<br>COMMAND — 进程名称（命令名/命令行）</p><p><strong>最常见使用</strong></p><ul><li><p>top        实时显示所有的进程信息</p></li><li><p>top -c         实时显示所有的进程信息（显示完整命令）</p></li><li><p>top -p PID    实时显示指定的进程信息</p></li><li><p>结束监控快捷键： q</p></li></ul><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>语法：ps [options] [–help]    查看进程信息     –无法实时监控，查看的为当前信息</p><p><strong>最常见使用</strong></p><ul><li>ps          显示当前正在运行的进程信息</li><li>ps -A         显示系统中所有的进程信息</li><li>ps -ef    显示系统中所有的进程信息(完整信息)</li><li>ps -u user 显示指定用户的进程信息</li></ul><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure><p> <strong>参数说明</strong>：</p><ul><li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li><li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li><li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li></ul><p>杀死一个进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 15642</span><br></pre></td></tr></table></figure><p>强制杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -KILL 15642</span><br></pre></td></tr></table></figure><p>彻底杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 15642</span><br></pre></td></tr></table></figure><p>杀死指定用户所有进程</p><p>1.方法一 过滤出itcast用户进程 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef | grep xxsleo) </span><br></pre></td></tr></table></figure><p>2.方法二，直接杀死</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -u xxsleo</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>上面列举了很多kill进程的命令</p><p>但是我们我们常用的就是kill -9命令，我们常常找到进程的pid</p><p>然后通过kill -9进行杀死进程</p></blockquote><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p>shutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机</p><p>使用者权限：管理员用户</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [-t seconds] [-rkhncfF] time [message]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-t seconds : 设定在几秒钟之后进行关机程序。</li><li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li><li>-r : 关机后重新开机。</li><li>-h : 关机后停机。</li><li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li><li>-c : 取消目前已经进行中的关机动作。</li><li>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。</li><li>-F : 关机时，强迫进行 fsck 动作。</li><li>time : 设定关机的时间。</li><li>message : 传送给所有使用者的警告讯息。</li></ul><p>立即关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br><span class="line">或者</span><br><span class="line">shudown</span><br></pre></td></tr></table></figure><p>指定1分钟后关机，1分钟关机并显示警告信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown +1 “System will shutdown after 1 minutes” </span><br></pre></td></tr></table></figure><p>指定1分钟后重启，并发出警告信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown –r +1 “1分钟后关机重启”</span><br></pre></td></tr></table></figure><h3 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h3><p>reboot命令用于用来重新启动计算机</p><p>使用者权限：管理员、普通（需要验证）用户</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot [-n] [-w] [-d] [-f] [-i]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-n : 在重开机前不做将记忆体资料写回硬盘的动作</li><li>-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</li><li>-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</li><li>-f : 强迫重开机，不呼叫 shutdown 这个指令</li><li>-i : 在重开机之前先把所有网络相关的装置先停止</li></ul><p>开始重新启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>此时我们的虚拟机正在重启<strong>（别忘记使用root用户执行）</strong></p><h3 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启</span><br></pre></td></tr></table></figure><p>who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等</p><p>使用者权限：所有使用者都可使用。</p><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who - [husfV] [user]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-H 或 –heading：显示各栏位的标题信息列；</li><li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；</li><li>-m：此参数的效果和指定”am i”字符串相同；</li><li>-q 或–count：只显示登入系统的帐号名称和总人数；</li><li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li><li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；</li><li>–help：在线帮助；</li><li>–version：显示版本信息</li></ul><p>显示当前登录系统的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure><p>显示明细(标题)信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -H</span><br></pre></td></tr></table></figure><h3 id="timedatectl命令"><a href="#timedatectl命令" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h3><p><strong>几个小概念：</strong><br>| 项目 | 说明|<br>| ———- | ———-|<br>|时区 | date命令可查看 |<br>| 系统时钟： System Clock | linux OS的时间，date命令可查看 |<br>| 硬件时钟：RTC : Real Time Clock | 主办上电池供电的BIOS时间，hwclock -r 可查看 |<br>| NTP: Network Time Protoctol | 本机时间和实际时间经常会有差别，一般使用NTP服务器进行时间校准 |<br><strong>常用命令：</strong></p><ul><li>timedatectl / timedatectl status        显示系统的当前时间和日期</li><li>timedatectl list-timezones             查看所有可用的时区</li><li>timedatectl set-timezone “Asia/Shanghai”    设置本地时区</li><li>timedatectl set ntp false                     禁用时间同步</li><li>timedatectl set-time “2022-01-20 13:59:00”  设置时间</li><li><strong>timedatectl set-ntp true                   启动时间同步</strong></li></ul><h3 id="clear命令"><a href="#clear命令" class="headerlink" title="clear命令"></a>clear命令</h3><ul><li>clear        清屏</li><li>注意：并不是把之前输入命令删掉，滚动条可以返回</li></ul><h2 id="Linux的目录管理"><a href="#Linux的目录管理" class="headerlink" title="Linux的目录管理"></a>Linux的目录管理</h2><h3 id="目录常用命令"><a href="#目录常用命令" class="headerlink" title="目录常用命令"></a>目录常用命令</h3><ul><li>ls:         列出目录</li><li>cd：     切换目录</li><li>pwd：  显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp:         复制文件或目录</li><li>rm:        移除文件或目录</li><li>mv:        移动文件与目录或修改文件与目录的名称</li></ul><p><strong>自动补全</strong></p><ul><li>在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 <code>tab</code>键</li><li>如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令</li></ul><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p><strong>常用命令：</strong></p><ul><li>ls                  显示不隐藏的文件与文件夹</li><li>ls -l                  显示不隐藏的文件与文件夹的详细信息</li><li>ls -al         显示所有的文件与文件夹的详细信息</li></ul><p><em>注意：</em></p><ul><li>隐藏文件和文件开头为 . </li><li>详细信息从左到右以此为：</li></ul><ul><li><strong>权限（A区域）</strong>, 第一个字符如果是 <code>d</code> 表示目录</li><li><strong>硬链接数（B区域）</strong>, 通俗的讲就是有多少种方式, 可以访问当前目录和文件</li><li><strong>属主（C区域）</strong>, 文件是所有者、或是叫做属主</li><li><strong>属组（D区域）</strong>, 文件属于哪个组</li><li><strong>大小（E区域）：文件大小</strong></li><li><strong>时间（F区域）：最后一次访问时间</strong></li><li><strong>名称（G区域）:文件的名称</strong></li></ul><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><ul><li>pwd显示当前目录<br>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在当前目录的命令。</li></ul><p>使用者权限：所有使用者都可使用。</p><p><strong>查看当前所在目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P</span><br></pre></td></tr></table></figure><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><ul><li>cd 切换目录</li><li>语法： cd 路径        切换目录</li></ul><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><ul><li>为make directory 的缩写</li><li>语法：mkdir [-p] 文件夹的名字    创建目录</li></ul><p>** 常用命令 **</p><ul><li>mkdir 文件夹名        创建目录</li><li>mkdir -p aaa/bbb              创建多级目录</li></ul><h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><ul><li>为remo directory 的缩写</li><li>语法：rmdir [-p] 文件夹名  删除空的目录</li></ul><p><strong>常用命令</strong></p><ul><li>rmdir 文件名        删除目录</li><li>rmdir -p bbb/ccc    删除ccc,如果删完之后bbb是空的，bbb也一起删除</li></ul><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><ul><li>为remo的缩写</li><li>语法：rm [选项] 文件/目录    删除文件或者目录</li></ul><p><strong>选项参数：</strong></p><ul><li>-i 删除前逐一询问确认</li><li>-f 即使原档案属性设为只读，也直接删除，无需逐一确认</li><li>-r 将目录及一下的档案逐一删除</li></ul><p><strong>常用命令</strong></p><ul><li>rm 文件路径        删除文件</li><li>rm -r 目录路径            删除目录和目录里面所有的内容</li></ul><p><em>注意：</em>一般使用rm比rmdir简单</p><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><ul><li>为copy的缩写</li><li>语法：cp [选项] 数据源 目的地   文件复制</li></ul><p><strong>选项参数：</strong></p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件。</li></ul><p><strong>常用命令</strong></p><ul><li>cp aaa/a.txt ccc        将aaa文件夹中的a.txt文件拷贝到ccc文件夹中</li><li>cp -r aaa/* ccc        将aaa文件夹中所有内容拷贝到ccc文件夹中</li></ul><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><ul><li>为move的缩写</li><li>语法：mv [选项] 数据源 目的地        改名/ 移动文件夹（看是否在同一目录下)</li></ul><p><strong>选项参数：</strong></p><ul><li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li></ul><p><strong>常用命令</strong></p><ul><li>mv 数据源 目的地        改名、移动</li></ul><p>** 注意 **</p><table><thead><tr><th align="left">命令格式</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">mv 文件名 文件名</td><td align="left">将源文件名改为目标文件名</td></tr><tr><td align="left">mv 文件名 目录名</td><td align="left">将文件移动到目标目录</td></tr><tr><td align="left">mv 目录名 目录名</td><td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td align="left">mv 目录名 文件名</td><td align="left">出错</td></tr></tbody></table><h2 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h2><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>每个文件的属性由左边第一部分的10个字符来确定。<br>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><ul><li>从左至右用0-9这些数字来表示。</li><li>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><h3 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h3><ul><li>为 change group 的缩写    （更改属组）</li></ul><p><strong>语法如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><ul><li>chgrp -v root aaa        将aaa的属组改为root</li><li>chgrp -R dev-group  /tmp/work</li></ul><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><ul><li>为 change owner 的缩写</li></ul><p><strong>语法如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown 属主名 文件名     更改属主</span><br><span class="line">chown [参数选项] 属主名:属主名 文件名更改属主和属组</span><br></pre></td></tr></table></figure><p><strong>选项参数:</strong></p><ul><li>-R    处理指定目录以及其子目录下的所有文件</li></ul><p><strong>常用命令:</strong></p><ul><li>chown root aaa        将aaa的属主改为root</li><li>chown root:root         将bbb的属主和属组改为root</li><li>chown -R root:root aaa     将aaa文件夹和里面所有的属主和属组改为root</li></ul><p><em>注意：linux命令区分大小写</em></p><h3 id="chmod权限命令"><a href="#chmod权限命令" class="headerlink" title="chmod权限命令"></a>chmod权限命令</h3><ul><li>为change mode 的缩写</li><li>作用：修改属主、属组、其他用户的权限</li><li>修改方式：<ol><li>数字方式</li><li>符号方式<h4 id="数字方式"><a href="#数字方式" class="headerlink" title="数字方式"></a>数字方式</h4></li></ol></li></ul><p><strong>权限属性</strong><br>| 权限 | 英文 | 缩写 | 数字序号 |<br>|— | — | — | — |<br>| 读 | read | r | 4 |<br>| 写 | write | w | 2 |<br>| 执行 | execute | x | 1 |<br>| 无权限 |  | - | 0 |</p><p><em>列：</em></p><ul><li>rwx = 4 + 2 +1 = 7    </li><li>设置数字5表示可读可执行</li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [参数选项] 数字权限 文件或目录</span><br></pre></td></tr></table></figure><p><strong>参数选项</strong></p><ul><li>-R :  对目前目录下所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>-v ：显示权限变更的详细资料</li></ul><p><strong>数字权限</strong></p><ul><li>数字类型的权限属性，为rwx对应数值相加的和。</li></ul><p><strong>举例</strong></p><ul><li>chmod -R 770 aaa</li></ul><h4 id="符号方式"><a href="#符号方式" class="headerlink" title="符号方式"></a>符号方式</h4><p><strong>符号权限</strong></p><ul><li>user     属主权限     -&gt; u</li><li>group  属组权限   -&gt; g</li><li>others 其他权限   -&gt; o</li><li>全部身份            -&gt; a</li></ul><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [参数选项] 符号权限 文件或目录</span><br></pre></td></tr></table></figure><p>符号权限格式：<br>    u/g/o/a        +/-/=(加入、除去、设定)        r/w/x<br><strong>参数选项</strong></p><ul><li>-R :  对目前目录下所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>-v ：显示权限变更的详细资料</li></ul><p><strong>符号权限</strong></p><ul><li>r、w、x、-</li></ul><p><strong>举例</strong></p><ul><li>chmod -R u=rwx,g=rx,o=r a.txt</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day04-209-长度最小的子数组</title>
      <link href="/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/20/Algorithm/Day04-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>定义一个变量，通过循环数组，每次叠加数组的各值和target进行对比</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">return</span> length;</span><br><span class="line">            &#125;</span><br><span class="line">            a += nums[i];</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：解答错误</li><li>原因：没仔细看题，题目说的是长度最小的子数组，这思路，只能找出最先大于target的子数组</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>两个for循环，一个遍历数组，一个使各个值从当前位置相加和target对比。</li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    length = Math.min(length, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">999999</span> ? <span class="number">0</span>:length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考后"><a href="#参考后" class="headerlink" title="参考后"></a>参考后</h2><p><strong>滑动窗口</strong>(本质还是双指针)</p><ul><li>思路：两个’指针’从头开始遍历数组, left指针先不动，right向右移，sum增加，若 target &gt;= sum, 此时 left向右移，开始下一初始位置的寻找，直到left=right.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2></li><li>认真读题！ 不能漏掉关键字！</li><li>学以致用，前几天刚学的双指针，没想到用。</li><li>下去多了解一下math函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day03-977-有序数组的平方</title>
      <link href="/2022/01/19/Algorithm/Day03-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2022/01/19/Algorithm/Day03-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= nums.length &lt;= 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>nums 已按 非递减顺序 排序</li></ul><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>循环数组，使值都变为平方，在用冒泡排序，进行非递减处理</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j+<span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：顺利通过，但是时间复杂度O(n + n^2)太高</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>想到了Java里其实是有内置的排序函数sort()的</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果：运行成功，把时间复杂度降到了O(n + nlogn);</li></ul><h2 id="参考后"><a href="#参考后" class="headerlink" title="参考后"></a>参考后</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>思路：</strong><br>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k–] = A[j] * A[j]; 。</p><p>如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k–] = A[i] * A[i]; 。</p><ul><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> index = result.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;</span><br><span class="line">                result[index--] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index--] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>思路没新意，太常规</li><li>对java一些基本函数有遗忘，要加强复习</li><li>多借鉴一些优秀的思路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA复习笔记</title>
      <link href="/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-复习"><a href="#JAVA-复习" class="headerlink" title="JAVA 复习"></a>JAVA 复习</h1><h2 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h2><p>Java基础语法（包括数组等），类与对象（包括对象数组等），String类（包括split等常用方法），继承与多态，抽象类与接口，异常类，面向抽象原则与开闭原则（包括类图等），图形用户界面基础，集合框架（包括List接口及其实现类ArrayList、Map接口及其实现类HashMap），文件管理与输入输出流（包括File类、字符流、字节流、缓冲流等）以及线程</p><h2 id="二、注意地方"><a href="#二、注意地方" class="headerlink" title="二、注意地方"></a>二、注意地方</h2><h3 id="1-Integer类"><a href="#1-Integer类" class="headerlink" title="1.  Integer类"></a>1.  Integer类</h3><ul><li>integer.toBinaryString()输出二进制</li></ul><h3 id="2-Arrays类"><a href="#2-Arrays类" class="headerlink" title="2. Arrays类"></a>2. Arrays类</h3><ul><li><p>该类包含用于操作数组的各种方法（如排序和搜索）。 该类还包含一个静态工厂，可以将数组视为列表。</p></li><li><p>排序<br>public static void sort(double a[])<br> 含义：把参数a指定的double类型数组按照升序排序<br>public static void sort(double a[], int start, int end)<br> 含义：把参数a指定的double类型数组中索引start至end-1 的元素的值按照升序排序</p></li><li><p>二分法查找（要求数组已排序）<br>public static int binarySearch(double[] a, double number)<br> 含义：判断参数number指定的数是否在a指定的数组中，再返回该元素的索引，不在，返回一个负数。</p></li><li><p>复制<br>public static int[] copyOf(int[] original, int newLength)<br> 含义：把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组。<br>public static int[] copyOfRange(int[] original, int from, int to)<br> 含义：把参数original指定的数组中从索引from开始到 to-1的元素复制到一个新数组中，并返回这个新数组。</p><h3 id="3-enum"><a href="#3-enum" class="headerlink" title="3. enum"></a>3. enum</h3></li><li><p>定义<br>enum  Season {</p><p>   SPRING, SUMMER, AUTUMN, WINTER<br>}</p></li><li><p>用法<br>Season a ;<br>a.SPRING;</p><h3 id="4-pattern类"><a href="#4-pattern类" class="headerlink" title="4. pattern类"></a>4. pattern类</h3></li><li><p>正则表达式会用到<br>正则表达式的编译表示。<br>必须首先将正则表达式（指定为字符串）编译为此类的实例。 然后将所得的图案可以被用来创建一个Matcher对象可以匹配任意character sequences针对正则表达式。 执行匹配的所有状态都驻留在匹配器中，所以许多匹配者可以共享相同的模式。<br>因此，典型的调用序列<br>Pattern p = Pattern.compile(“a*b”);<br>Matcher m = p.matcher(“aaaaab”);<br>boolean b = m.matches();</p></li></ul><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><ol><li>长方形分为三块</li></ol><ul><li>类名（抽象类为斜体）</li><li>变量名</li><li>方法名</li><li>注意：public 为 + , 默认为缺省，protect为#，private为-；</li></ul><ol start="2"><li>关联 —&gt;</li><li>依赖 —-&gt;\</li><li>继承 —▷</li><li>实现接口 —-▷</li></ol><h3 id="6-JScrollPane"><a href="#6-JScrollPane" class="headerlink" title="6. JScrollPane"></a>6. JScrollPane</h3><p>提供轻量级组件的可滚动视图。 A JScrollPane管理视口，可选的垂直和水平滚动条以及可选的行和列标题视口。 您可以在How to Use Scroll Panes中找到面向任务的JScrollPane JScrollPane ， 这是Java教程中的一节。 请注意， JScrollPane不支持重量级组件。 </p><h3 id="7-Dimension"><a href="#7-Dimension" class="headerlink" title="7. Dimension"></a>7. Dimension</h3><p>Dimension类封装单个对象中组件的宽度和高度（以整数精度）。 该类与组件的某些属性相关联。 Component类和LayoutManager接口定义的几种方法返回一个Dimension对象。 </p><h3 id="3-三种布局"><a href="#3-三种布局" class="headerlink" title="3. 三种布局"></a>3. 三种布局</h3><ul><li>GridLayout-网格布局</li><li>BorderLayout-边框布局</li><li>FlowLayout-流式布局</li></ul><h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h3><h2 id="三、查缺补漏"><a href="#三、查缺补漏" class="headerlink" title="三、查缺补漏"></a>三、查缺补漏</h2><h3 id="1-移位运算"><a href="#1-移位运算" class="headerlink" title="1. 移位运算"></a>1. 移位运算</h3><ul><li>移位运算符</li></ul><p>** 二进制移位，移动一位相当于*2 || /2 **<br> &lt;&lt; （带符号左移） </p><blockquote><blockquote><p>（带符号右移） </p><blockquote><p>（无符号右移）<br> 列： D:\ideaWorkspace\review\src\displacement.java </p></blockquote></blockquote></blockquote><ul><li><strong>疑问： java输出负数二进制表现和机组不一样？</strong></li></ul><h3 id="2-数组的表示"><a href="#2-数组的表示" class="headerlink" title="2. 数组的表示"></a>2. 数组的表示</h3><ol><li>定义、</li></ol><ul><li>int a[]; // 不推荐</li><li>int [] a;</li></ul><ol start="2"><li>初始化</li></ol><ul><li>int a[] = new int[x];</li><li>int a[] = new int[]{1,2,3,4};</li><li>int a[] = {1,2,3,4}</li></ul><p>** 3. 注意：java不允许在声明数组中的方括号内指定数组长度。**</p><h3 id="3-修饰符表示范围"><a href="#3-修饰符表示范围" class="headerlink" title="3. 修饰符表示范围"></a>3. 修饰符表示范围</h3><table><thead><tr><th>修饰符</th><th>访问位置</th></tr></thead><tbody><tr><td>private</td><td>该类</td></tr><tr><td>默认</td><td>同一个包</td></tr><tr><td>protect</td><td>同一个项目</td></tr><tr><td>public</td><td>任何位置</td></tr></tbody></table><h3 id="4-抽象和接口的区别"><a href="#4-抽象和接口的区别" class="headerlink" title="4. 抽象和接口的区别"></a>4. 抽象和接口的区别</h3><ol><li>抽象</li></ol><ul><li>abstract方法没有方法体</li></ul><ol start="2"><li>接口</li></ol><ul><li>只能用public 和 空缺</li><li>默认为public 可以不写public</li></ul><p>** 接口规定类做什么，抽象类增加代码复用性**<br><em>见CSDN收藏</em></p><h3 id="5-Lambda表达式"><a href="#5-Lambda表达式" class="headerlink" title="5 . Lambda表达式"></a>5 . Lambda表达式</h3><ol><li>定义：Lambda表达式是一个匿名函数，即没有函数名的函数</li><li>表现形式：（参数/无参）-&gt; {多行语句}；</li><li>用法：一般用于匿名内部类，有单个方法。</li></ol><h3 id="6-输入输出流，缓冲流"><a href="#6-输入输出流，缓冲流" class="headerlink" title="6. 输入输出流，缓冲流"></a>6. 输入输出流，缓冲流</h3><ol><li>字符流</li></ol><ul><li>FileWriter</li><li>FileReader</li><li>注意方法：<br>fr.read() 读到末尾返回-1</li></ul><ol start="2"><li>字节流</li></ol><ul><li>FileInputStream</li><li>FileoutputStream</li></ul><ol start="3"><li>缓冲流</li></ol><ul><li>BufferedWriter</li><li>BufferedReader</li><li><em>创建的时候依赖与其他流 列： bf = new BufferedReader(fr)</em></li><li>注意的方法：<br>bw.readLine() 读一行  <em>不能写成 .read() , 为读一个字符</em>  //返回String<br>bw.newLine() 写一行行分隔符</li></ul><p>** 最后都需要关闭流（.close(）)    缓冲流要在文件流之前关闭**</p><h3 id="7-集合框架"><a href="#7-集合框架" class="headerlink" title="7. 集合框架"></a>7. 集合框架</h3><ul><li>迭代器 — 重点map</li></ul><ol><li>迭代器输出map的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; itervalue = map.values().iterator();</span><br><span class="line">while(itervalue.hasNext()) &#123;</span><br><span class="line">Sout(itervalue.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器输出map键-值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer,Student&gt;&gt; iterEntry = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterEntry.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer,Student&gt; entry =       (Map.Entry&lt;Integer,Student&gt;)iterEntry.next();  <span class="comment">//创造具体对象 类似于 new</span></span><br><span class="line">sout(iterEntry.getKey() + <span class="string">&quot;&lt;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-String-split"><a href="#8-String-split" class="headerlink" title="8. String split"></a>8. String split</h3><ul><li>将此字符串分割为给定的 regular expression的匹配。 </li><li>列：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;a-b-c-d&quot;;</span><br><span class="line">sout(s.split(-));</span><br><span class="line">结果： ab  c  d</span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title=". 正则表达式"></a>. 正则表达式</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习笔记</title>
      <link href="/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA学习笔记"><a href="#JAVA学习笔记" class="headerlink" title="JAVA学习笔记"></a>JAVA学习笔记</h1><h2 id="Day01-2021-8-8"><a href="#Day01-2021-8-8" class="headerlink" title="Day01 2021/8/8"></a>Day01 2021/8/8</h2><h1 id="一、注意"><a href="#一、注意" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>布尔常量是可以输出的</li><li>null不可以输出<h1 id="二、错误总结"><a href="#二、错误总结" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>float f=13.14;<pre><code> System.out.println(&quot;f&quot;)；错误</code></pre> 应该(f);<h2 id="Day02-2021-8-9"><a href="#Day02-2021-8-9" class="headerlink" title="Day02 2021/8/9"></a>Day02 2021/8/9</h2><h1 id="一、注意-1"><a href="#一、注意-1" class="headerlink" title="一、注意"></a>一、注意</h1></li><li>类型转换可以是从小到大，强制类型转换是从大转小（不建议使用，有数据丢失）</li><li><pre><code>    System.out.println(5.2 / a);//可以得到小数</code></pre></li><li>‘0’ Asics为48 ‘0–9’连续</li><li>算术表达式中包&lt;含多个数据类型&gt;的值的时候，整个算术表达式的类型会自动提升。</li><li><pre><code> System.out.println(&quot;黑马&quot; + 6 + 66); ——黑马666 System.out.println(1 + 99 + &quot;年黑马&quot;);———100黑马 总结： 从左到右运算</code></pre></li><li>+=包含了强制类型转换—(不建议)<br> short s=10;<br> s += 20; 正确        等同于s = (short)(s + 20)<br> s = s + 20; 错误 </li><li>b = a++; a值先给b，再++。一般单独使用++；</li><li>异或^ 相同为T,不同为F</li><li>短路与|| 左边为真右边不执行<br> 短路或&amp;&amp; 左边为假右边不执行<h1 id="二、错误总结-1"><a href="#二、错误总结-1" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>c=”A”,为字符串（String),  c=’A’，为单个字符；</li></ol><h2 id="Day03-2021-8-10"><a href="#Day03-2021-8-10" class="headerlink" title="Day03 2021/8/10"></a>Day03 2021/8/10</h2><h1 id="一、注意-2"><a href="#一、注意-2" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>测试数据：选择正确数据、边界数据、错误数据。</li><li>for循环里的循环变量，出了循环不可使用。while循环里的变量，全局都可以使用。</li><li>for( ; ; )为for的死循环    ctrl+c可以结束循环</li></ol><h2 id="Day04-2021-8-11"><a href="#Day04-2021-8-11" class="headerlink" title="Day04 2021/8/11"></a>Day04 2021/8/11</h2><h1 id="一、注意-3"><a href="#一、注意-3" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>反复练习idea操作</li></ol><h1 id="二、错误总结-2"><a href="#二、错误总结-2" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>idea中一旦选定文件储存区域，不能对文件进行重命名。</li></ol><h1 id="idea里的快捷键"><a href="#idea里的快捷键" class="headerlink" title="idea里的快捷键"></a>idea里的快捷键</h1><ol><li>快速生成mian() psvm,</li><li>快速生成输出 sout</li><li>内容辅助 ctrl + Alt + space</li><li>ctrl + Alt + l 修改代码标准格式</li><li>ctrl + Alt + v 代码自动补全</li></ol><h2 id="Day05-2021-8-12"><a href="#Day05-2021-8-12" class="headerlink" title="Day05 2021/8/12"></a>Day05 2021/8/12</h2><h1 id="一、注意-4"><a href="#一、注意-4" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>方法重载</li><li>输出语句</li><li>从问题中提炼数据，从数据中寻找规律，从规律中程序化。<h1 id="二、错误总结-3"><a href="#二、错误总结-3" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>该错误要一改都改，记得改了同样出现的地方。</li></ol><h2 id="Day06-2021-8-13"><a href="#Day06-2021-8-13" class="headerlink" title="Day06 2021/8/13"></a>Day06 2021/8/13</h2><h1 id="一、注意-5"><a href="#一、注意-5" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>private 修饰成员变量</li><li>this关键字，加载变量前，解决局部变量隐藏成员变量</li><li>构造方法，在类中 public Student() {};</li><li>构造方法就相当于方法   函数；</li></ol><h1 id="二、错误总结-4"><a href="#二、错误总结-4" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>给字符串（String）赋值要加引号，单引号、双引号；</li></ol><h2 id="Day07-2021-8-14"><a href="#Day07-2021-8-14" class="headerlink" title="Day07 2021/8/14"></a>Day07 2021/8/14</h2><h1 id="一-注意"><a href="#一-注意" class="headerlink" title="一,注意"></a>一,注意</h1><h1 id="二-错误总结"><a href="#二-错误总结" class="headerlink" title="二,错误总结"></a>二,错误总结</h1><ol><li>System.out.println(“输入的数据是：” + line);    正确—-不能写成System.out.println(“输入的数据是： + line”);</li></ol><h2 id="Day08-2021-8-15"><a href="#Day08-2021-8-15" class="headerlink" title="Day08 2021/8/15"></a>Day08 2021/8/15</h2><h1 id="一、注意-6"><a href="#一、注意-6" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li><code>[用==作比较：  基本类型：比较的是数据值是否相同      应用类型：比较的是地址值是否相同]</code>()</li><li><code>比较字符串用方法：.equals()    public boolen equals(Object and Obeject);    s1.equals(s2)</code></li><li>获取字符串中单个字符 .charAt();    </li><li>获取字符串的长度 .length();</li><li>String是可变的，StringBuilde是不可变的。</li><li>StringBulider中append添加数据并返回数据本身    reverse反转<br> B-&gt;S转换String s = sb.toString();<br> S-&gt;B转换StringBuilder sb = new StringBuilder(s);</li><li>ArrayList方法：<br> 删除–返回是否成功<br> array.remove(“world”);<br> 删除指定位置–返回别删除元素<br> array.remove(1);<br> //修改指定位置索引，返回被修改元素<br> System.out.println(array.set(1,”nima”));<pre><code> //返回索引处的元素 System.out.println(array.get(1));   //返回集合中元素的个数 System.out.println(array.size()); //输出集合 System.out.println(array); //添加 add</code></pre></li></ol><h1 id="二、错误总结-5"><a href="#二、错误总结-5" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>一般数组或者字符串的遍历用for()循环</li><li>定义变量必须初始化(与C语言不同)</li><li>字符串可以定义byte {97}输出字符，s.charAt(a) &gt;= 97正确</li><li>数字不带引号，字符串带引号；</li><li>一开始写不能忘记main方法！！！<h1 id="Day09-8-18"><a href="#Day09-8-18" class="headerlink" title="Day09/8/18"></a>Day09/8/18</h1></li></ol><h2 id="一-注意-1"><a href="#一-注意-1" class="headerlink" title="一.注意"></a>一.注意</h2><ol><li><p>快捷键 alt + insert    根据自己的需要进行选择。</p></li><li><h2 id="字符串比较不能用-比较！！！！用equal！！！"><a href="#字符串比较不能用-比较！！！！用equal！！！" class="headerlink" title="字符串比较不能用 == 比较！！！！用equal！！！"></a>字符串比较不能用 == 比较！！！！用equal！！！</h2></li><li><h2 id="多想！！多尝试！！把问题全面化，简单化！！一定可以！"><a href="#多想！！多尝试！！把问题全面化，简单化！！一定可以！" class="headerlink" title="多想！！多尝试！！把问题全面化，简单化！！一定可以！"></a>多想！！多尝试！！把问题全面化，简单化！！一定可以！</h2></li></ol><h2 id="二、错误总结-6"><a href="#二、错误总结-6" class="headerlink" title="二、错误总结"></a>二、错误总结</h2><ol><li>System.exit(0);   退出程序.</li><li>switch用String的好处，输入出错，程序不会报错，还可以继续运行下去，直到输入正确的选择。</li><li>输出特殊含义的方法   在sout里不能加引号。</li><li>用ArrayLiss中数据时，必学先取出对象，再调用对象的方法。</li><li>多思考！！！！！摆脱惯性思维！！！！！！</li><li>while 和 for里定义的变量外界不能用，但在外界定义，在里面赋值操作，外界同样改变！</li></ol><h1 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h1><h2 id="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"><a href="#程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！" class="headerlink" title="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"></a>程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！</h2><h2 id="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"><a href="#相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！" class="headerlink" title="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"></a>相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！</h2><h2 id="d-StudentManger-delete-update-Student-里对学号不存在的判断"><a href="#d-StudentManger-delete-update-Student-里对学号不存在的判断" class="headerlink" title="d://StudentManger    delete\update Student 里对学号不存在的判断"></a>d://StudentManger    delete\update Student 里对学号不存在的判断</h2><h2 id="从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！"><a href="#从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！" class="headerlink" title="从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！"></a>从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！</h2><h1 id="Day10-09-11"><a href="#Day10-09-11" class="headerlink" title="Day10/09/11"></a>Day10/09/11</h1><h2 id="一、注意-7"><a href="#一、注意-7" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>继承格式 public class  zi extends fu() {};</li><li>构造方法和成员方法：<br> 1.构造方法 构造方法作用概述 给对象的数据进行初始化 构造方法格式 方法名与类名相同 没有返回值类型,连void都没有 没有具体的返回值 构造方法注意事项 如果你不提供构造方法,系统会给出默认构造方法 如果你…<br> 2.成员方法 成员方法作用概述 表示对象所具有的功能(和行为)。 成员方法格式 有返回类型,可以为void类型,也可以是基本数据类型.</li><li>继承中变量 、方法的访问特点：<br> 先方法，再成员变量，再父类<br> 想访问成员用this,想访问父类用super</li><li>@override<br>@Override这个标签有什么用呢。。。。。。<br>其实我也是比较迷茫，查了一下，三个作用吧</li><li>可以给你当作注释用，感觉这个也不能说明什么，注释也没什么用。</li><li>可以告诉读你代码的人，这是对它父类方法的重写，其实很多代码规范没有为什么，规范就是规范，代码的可读性还是很重要的。</li><li>编译器可以给你验证@Override下面的方法名称是否是你父类中所有的，如果没有就会报错。</li><li>访问权限：public &gt; 默认 &gt; privata</li><li>类只支持单继承，不支持多继承，但支持多层继承。</li></ol><h1 id="Day11-09-12"><a href="#Day11-09-12" class="headerlink" title="Day11/09/12"></a>Day11/09/12</h1><h2 id="一、注意-8"><a href="#一、注意-8" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>java se :标准版 用于开发桌面应用</li><li>java ee: 企业版</li><li>java me: 微型</li></ol><h1 id="Day11-09-26"><a href="#Day11-09-26" class="headerlink" title="Day11/09/26"></a>Day11/09/26</h1><h2 id="一、注意-9"><a href="#一、注意-9" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>导包，文件直接创建，cmd      java d . Hello.java</li><li>修饰符 （publick) （protected)     (默认)    (private)</li><li>状态修饰符<br> final 最终，修饰成员 1. 方法，2. 成员变量，3. 类，4. 局部变量，5. 引用变量（如 final Student s = new Student;)。<ol><li>最终方法，不能被重写；</li><li>变量为常量，不能再次被赋值；</li><li>最终类，不能被继承。</li><li>数据值不能变；</li><li>地址值不能变，但是地址值里的内容可以变。</li></ol><hr> static 静态，可以修饰成员方法，成员变量。<ol><li>特点： 别类的所有对象共享；——–也是判断是否使用静态关键字的条件。</li><li>可以使用对象名调用，也可以使用类名调用。&lt;推荐类名调用&gt;</li><li>静态成员方法只能访问静态成员。</li><li>非静态都可以访问。</li><li>main通常为静态 所以，类下面的方法一般也为静态。<h1 id="Day12-2021-9-29"><a href="#Day12-2021-9-29" class="headerlink" title="Day12/2021/9/29"></a>Day12/2021/9/29</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="一、-多态中成员访问特点"><a href="#一、-多态中成员访问特点" class="headerlink" title="一、 多态中成员访问特点"></a>一、 <strong>多态中成员访问特点</strong></h3></li></ol></li><li></li></ol><p>![e043f945ba7d7bd37ad0329bbe9bc4a](C:\Users\23694\AppData\Local\Temp\WeChat Files\e043f945ba7d7bd37ad0329bbe9bc4a.png)<br>2. **多态的好处与弊端</p><p>![df065b619113d744a14b7e889e6837e](C:\Users\23694\AppData\Local\Temp\WeChat Files\df065b619113d744a14b7e889e6837e.png)</p><ol start="3"><li><p>**多态的转型<br>//多态</p><pre><code> Arimal a = new Cat(); //1.从子到父，父类引用指向子类对象、向上转型 a.eat();//2.从父到子，向下转型，父类引用转为子类对象 Cat c = (Cat)a; c.playGame(); //逆着看 </code></pre><h1 id="Day13-2021-10-06"><a href="#Day13-2021-10-06" class="headerlink" title="Day13/2021/10/06"></a>Day13/2021/10/06</h1><h2 id="抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png"><a href="#抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png" class="headerlink" title="抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)"></a>抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)</h2><h3 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h3></li></ol><h1 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h1><ol><li>![9ddca1064128fcc4f0de5b42eb43295](C:\Users\23694\AppData\Local\Temp\WeChat Files\9ddca1064128fcc4f0de5b42eb43295.png)String 定义的变量赋值要加 ”“；</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="一、接口的特点"><a href="#一、接口的特点" class="headerlink" title="一、接口的特点"></a>一、接口的特点</h2><ol><li>用关键字Interface修饰；</li><li>类实现接口用implement</li><li>接口不能实例化<br> *可用多态方式，通过实现对象实例化，这叫接口多态。</li><li><strong>多态的形式<br> 具体类多态、抽象类多态、接口多态</strong></li><li><strong>多态的前提<br> 有继承或者实现关系； 有方法重写；有父类的（接口/类)引用指向(子/实现)类对象</strong><h2 id="二、接口的成员特点"><a href="#二、接口的成员特点" class="headerlink" title="二、接口的成员特点"></a>二、接口的成员特点</h2></li><li></li></ol><p>![8b1956872eda32d7978c71682dcc980](C:\Users\23694\AppData\Local\Temp\WeChat Files\8b1956872eda32d7978c71682dcc980.png)<br>2. 接口不可以实列化** 当有的方参数为接口时，调用的是接口的implement。测试类中也要用堕胎的方式创建接口**</p><h1 id="Day14-2021-10-24"><a href="#Day14-2021-10-24" class="headerlink" title="Day14/2021/10/24"></a>Day14/2021/10/24</h1><h1 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h1><p>*练习文件所在位置D:\ideaWorkspace-practice\src\：</p><h2 id="1-1-访问特点"><a href="#1-1-访问特点" class="headerlink" title="1. 1 访问特点"></a>1. 1 访问特点</h2><ol><li>内部类可以直接反问外部类的成员、包括私有</li><li>外部类要想访问内部类。必需创建对象</li></ol><h3 id="1-1-1分类"><a href="#1-1-1分类" class="headerlink" title="1.1.1分类"></a>1.1.1分类</h3><blockquote><blockquote><p>成员内部类<br>局部内部类</p></blockquote></blockquote><h2 id="1-2成员内部类"><a href="#1-2成员内部类" class="headerlink" title="1.2成员内部类"></a>1.2成员内部类</h2><h3 id="1-2-1成员内部类如何创建使用"><a href="#1-2-1成员内部类如何创建使用" class="headerlink" title="1.2.1成员内部类如何创建使用"></a>1.2.1成员内部类如何创建使用</h3><blockquote><blockquote><p>格式  ： 外部类名.内部类名 对象名 = 外部类对象.内部类对象<br>范列  ：        Outher.Inner i = new Outher().new Inner();</p><blockquote><p>注意：还有一种是在外部类方法中创建内部类对象，在测试类中直接调用该方法，实现成员内部类的创建和使用。</p></blockquote></blockquote></blockquote><h2 id="1-3局部内部类"><a href="#1-3局部内部类" class="headerlink" title="1.3局部内部类"></a>1.3局部内部类</h2><h3 id="1-3-1定义"><a href="#1-3-1定义" class="headerlink" title="1.3.1定义"></a>1.3.1定义</h3><blockquote><blockquote><p>在方法中定义的类。外界无法显示，需要在方法内部创建对象并使用该类，可以直接访问外部类的成员，也可以访问方法内的局部变量；</p></blockquote></blockquote><h2 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h2><p><em>局部内部类的一种特俗形式</em><br><strong>前提</strong> ： 存在一个类或者接口，这里类可以是具体类也可以是抽象类<br><strong>本质</strong> :   是一个继承了该类或者实现了该接口的子类^匿名对象^</p><h3 id="1-4-1-格式"><a href="#1-4-1-格式" class="headerlink" title="1.4.1 格式"></a>1.4.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名() &#123;  </span><br><span class="line">重写方法；^说明继承了前面的类或者说实现了一个接口^</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>最后的分号不能忘</strong></p><h3 id="1-4-2-调用"><a href="#1-4-2-调用" class="headerlink" title="1.4.2 调用"></a>1.4.2 调用</h3><blockquote><blockquote><p>可以利用多态的方法赋值给类或者接口 ，对类或者接口进行方法调用。</p></blockquote></blockquote><h2 id="1-5-匿名内部类在开发中的作用"><a href="#1-5-匿名内部类在开发中的作用" class="headerlink" title="1.5 匿名内部类在开发中的作用"></a>1.5 匿名内部类在开发中的作用</h2><h3 id="1-5-1案例"><a href="#1-5-1案例" class="headerlink" title="1.5.1案例"></a>1.5.1案例</h3><p> //使用匿名内部类，可以使不用创建具体的猫对象<br>        jo.method(new Jumpping() {<br>            @Override<br>            public void jump() {<br>                System.out.println(“狗会跳”);<br>            }<br>        });</p><h3 id="一、注意-10"><a href="#一、注意-10" class="headerlink" title="一、注意"></a>一、注意</h3><ol><li><strong>通用</strong> 类里不能直接输出（sout),必须创建方法;</li><li><strong>通用</strong>所有可以实现的方法颜色都会发生改变；</li></ol><h3 id="二、错误总结-7"><a href="#二、错误总结-7" class="headerlink" title="二、错误总结"></a>二、错误总结</h3><h1 id="day15-2021-10-26"><a href="#day15-2021-10-26" class="headerlink" title="day15/2021/10/26"></a>day15/2021/10/26</h1><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h1 id="1、Math"><a href="#1、Math" class="headerlink" title="1、Math"></a>1、Math</h1><h2 id="1-1-Math类概述"><a href="#1-1-Math类概述" class="headerlink" title="1.1 Math类概述"></a>1.1 Math类概述</h2><blockquote><blockquote><p>基本数学方法</p></blockquote></blockquote><h2 id="1-2-Math类的常用方法"><a href="#1-2-Math类的常用方法" class="headerlink" title="1.2 Math类的常用方法"></a>1.2 Math类的常用方法</h2><ol><li>abs(int )——绝对值</li><li>ceil(double )——大于或等于参数的最小double值</li><li>floor(double )——小与或等于参数的最大double值</li><li>round(float )——四舍五入返回最接近参数的int</li><li>max(int )——较大值</li><li>min(int )——较小值</li><li>pow(double a, double b)——a的b次幂</li><li>random( )——返回为double的正直，[0.0,1.0)    <em>（int)random())可强转为int</em></li></ol><h1 id="2、System"><a href="#2、System" class="headerlink" title="2、System"></a>2、System</h1><h2 id="2-1-System类概述"><a href="#2-1-System类概述" class="headerlink" title="2.1 System类概述"></a>2.1 System类概述</h2><p><strong>包含几个有用的类字段和方法，它不能被实例化。</strong></p><h2 id="2-2-System类的常用方法"><a href="#2-2-System类的常用方法" class="headerlink" title="2.2 System类的常用方法"></a>2.2 System类的常用方法</h2><ol><li>exit(0)——终止当前运行的java虚拟机，非零表示异常终止</li><li>currentTimeMillis()——返回当前时间（以毫秒为单位）<br> *可以用来计算for循环耗时<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long strat = System.currentTimeMillis();</span><br><span class="line">for();</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">sout(&quot;time&quot; = strat - long);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="3、Object"><a href="#3、Object" class="headerlink" title="3、Object"></a>3、Object</h1><h2 id="3-1-Object类的概述"><a href="#3-1-Object类的概述" class="headerlink" title="3.1 Object类的概述"></a>3.1 Object类的概述</h2><p>** Class Object是类Object结构的根。 每个班都有Object作为超类。 所有对象（包括数组）都实现了这个类的方法。**</p><h3 id="3-1-1构造方法"><a href="#3-1-1构造方法" class="headerlink" title="3.1.1构造方法"></a>3.1.1构造方法</h3><p><strong>public Object();</strong></p><h2 id="3-2-Object类的常用方法"><a href="#3-2-Object类的常用方法" class="headerlink" title="3.2 Object类的常用方法"></a>3.2 Object类的常用方法</h2><ol><li>toString()——输出对象地址<em>建议所有子类都重写</em></li><li>equals()——</li></ol><h1 id="day16-2021-11-13"><a href="#day16-2021-11-13" class="headerlink" title="day16/2021/11/13"></a>day16/2021/11/13</h1><p><strong>==一些基础总结==</strong></p><h2 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h2><ol><li>JCheckBox 复选框 getText()</li><li>JComboBox 下拉列表 .getSelectedItem().toString()</li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>final abstract 不能同时出现</li><li>接口里也可以有抽象方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">public interface Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //A</span><br><span class="line"></span><br><span class="line">    public int x = 0;          //B </span><br><span class="line"></span><br><span class="line">    static int y = 0;          //C</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Cat implements Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //D</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  abstract void cry(); </span><br><span class="line">B. public int x = 0;</span><br><span class="line">C.  static int y = 0; </span><br><span class="line">D. abstract void cry(); </span><br><span class="line">我的答案: D正确答案: D</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>抽象方法必须实现，接口不一定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">interface Com &#123;</span><br><span class="line"></span><br><span class="line">    int MAX = 100;  //A</span><br><span class="line"></span><br><span class="line">    void f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal implements Com &#123;</span><br><span class="line"></span><br><span class="line">    int MIN ;      //B</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    public void f() &#123;  </span><br><span class="line"></span><br><span class="line">       MIN = 10;     //C</span><br><span class="line"></span><br><span class="line">       MAX = 200;    //D</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  int MAX = 100;</span><br><span class="line">B.  int MIN ; </span><br><span class="line">C. MIN = 10; </span><br><span class="line">D. MAX = 200; </span><br><span class="line">我的答案: D正确答案: D</span><br></pre></td></tr></table></figure></li><li>接口方法只能用public 、 默认<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口中的方法也可以用private或protected修饰。</span><br><span class="line">A. 对</span><br><span class="line">B. 错</span><br><span class="line">我的答案: 错正确答案: 错</span><br></pre></td></tr></table></figure><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2></li><li>(判断题)子类在方法重写时，不可以把父类的实例方法重写为类（static）方法，也不可以把父类的类（static）方法重写为实例方法。</li><li>子类继承父类的构造方法。<br>我的答案: 错正确答案: 错<br>答案解析：子类有子类的构造方法，父类有父类的构造方法，子类是不会继承父类的构造函数的，只是必须调用</li><li>** 继承普通父类可以方法重写，继承继承抽象类不可以。**</li></ol><p><strong>== 注 ==</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. (单选题)</span><br><span class="line">下列哪个代码（A，B，C，D）放入程序中标注的【代码】处将导致编译错误？</span><br><span class="line"></span><br><span class="line">class A &#123; </span><br><span class="line"></span><br><span class="line">   public float getNum() &#123;</span><br><span class="line"></span><br><span class="line">       return 3.0f;</span><br><span class="line"></span><br><span class="line">   &#125;     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class B extends A &#123; </span><br><span class="line"></span><br><span class="line">      【代码】</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A. public float getNum()&#123;return 4.0f;&#125; </span><br><span class="line">B.  public void getNum()&#123; &#125;   **√**</span><br><span class="line">C.  public void getNum(double d)&#123; &#125; </span><br><span class="line">D.  public double getNum(float d)&#123;return 4.0d;&#125;</span><br><span class="line"></span><br><span class="line">可以重写方法如改变（），不可以改变返回值类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="day17-2021-11-17"><a href="#day17-2021-11-17" class="headerlink" title="day17/2021/11/17"></a>day17/2021/11/17</h1><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\V{W{LYR]J}PIRL6CIA_NO33.png"></p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><h3 id="1-2-集合类结构体"><a href="#1-2-集合类结构体" class="headerlink" title="1,2 集合类结构体"></a>1,2 集合类结构体</h3><p>** 集合分为Collection和Map**<br>** Cpllection 分为list \ set  **</p><h3 id="1-3Collection"><a href="#1-3Collection" class="headerlink" title="1.3Collection"></a>1.3Collection</h3><h4 id="1-3-1创建Collection集合的对象"><a href="#1-3-1创建Collection集合的对象" class="headerlink" title="1.3.1创建Collection集合的对象"></a>1.3.1创建Collection集合的对象</h4><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul><h3 id="1-4-Collection的常用方法"><a href="#1-4-Collection的常用方法" class="headerlink" title="1.4 Collection的常用方法"></a>1.4 Collection的常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\M(]U7X8VZ3QLJGM]Z4RI%JW.png"></p><h3 id="1-5Collection遍历"><a href="#1-5Collection遍历" class="headerlink" title="1.5Collection遍历"></a>1.5Collection遍历</h3><p><strong>iterator 迭代器,集合专用遍历方式</strong><br> iterator<E> iterator(): 返回集合中元素的迭代器，通过iterator()方法得到 <strong>==        Iterator<String> it = list.iterator();==</strong></p><ul><li>依赖与集合存在</li></ul><p><strong>常用方法</strong></p><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构[9Z(}TRZWC%_UI5)C@QL~5B.png"></p><h3 id="1-6集合的使用步骤"><a href="#1-6集合的使用步骤" class="headerlink" title="1.6集合的使用步骤"></a>1.6集合的使用步骤</h3><ol><li>创建集合对象</li><li>添加元素</li><li>遍历集合（三总遍历方式）<blockquote><p>利用size（）和for循环<br>增强for循环<br>迭代器iterator</p></blockquote></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>== 如何把多个对象一起加入集合==</strong><br><strong>== hashCode==</strong></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>AlT + 7 打开一个窗口，可以看到类的所有信息</strong><br>**ctrl + alt + v 、补全代码</p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><h3 id="2-1-List集合概述和特点"><a href="#2-1-List集合概述和特点" class="headerlink" title="2.1 List集合概述和特点"></a>2.1 List集合概述和特点</h3><ul><li>概述：</li><li>有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 </li><li>与Set集合不同，列表允许重复元素</li><li>特点：</li><li>有序：存储和取出的元素顺序一致</li><li>可重复：存储的元素可重复<h3 id="2-2-List集合特有方法"><a href="#2-2-List集合特有方法" class="headerlink" title="2.2 List集合特有方法"></a>2.2 List集合特有方法</h3></li></ul><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\list特有方法.png"></p><h3 id="2-3并发修改异常"><a href="#2-3并发修改异常" class="headerlink" title="2.3并发修改异常"></a>2.3并发修改异常</h3><ul><li>ConcurrentModificationException</li><li>产生原因：</li><li>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致。</li></ul><h3 id="2-4Listlterator"><a href="#2-4Listlterator" class="headerlink" title="2.4Listlterator"></a>2.4Listlterator</h3><blockquote><p>列表迭代器</p></blockquote><ul><li><p>集合特有的迭代器</p></li><li><p>用于允许程序员沿任一方向遍历列表的列表的迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</p></li><li><p>常用方法：</p></li><li><p>next（）、hasNext()、previous（）、hasPrevious（）</p></li><li><p>addE e() ** 不会出现并发异常##</p></li></ul><h3 id="2-5-增强for循环"><a href="#2-5-增强for循环" class="headerlink" title="2.5 增强for循环"></a>2.5 增强for循环</h3><blockquote><p>简化数组和Collection集合的遍历<br>实际上为iterator迭代器</p></blockquote><ul><li>格式</li><li>for(元素类型 变量名 ：数组或集合名 ) { 变量既为该元素}</li></ul><h3 id="2-6数据结构"><a href="#2-6数据结构" class="headerlink" title="2.6数据结构"></a>2.6数据结构</h3><h3 id="2-7-常见数据结构"><a href="#2-7-常见数据结构" class="headerlink" title="2.7 常见数据结构"></a>2.7 常见数据结构</h3><h3 id="2-8-linkedList常用方法"><a href="#2-8-linkedList常用方法" class="headerlink" title="2.8 linkedList常用方法"></a>2.8 linkedList常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\852.png"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>//调用迭代器方法 不是new一个迭代器对象，不用new<pre><code> ListIterator&lt;String&gt; lit =  list.listIterator();</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 黑马程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程单词积累</title>
      <link href="/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/"/>
      <url>/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="编程单词"><a href="#编程单词" class="headerlink" title="编程单词"></a>编程单词</h1><ol><li>object 对象</li><li>geometric 几何图形</li><li>circle 圆</li><li>rectangle 长方体</li><li>radius 半径</li><li>Perimeter周长</li><li>Diameter 直径</li><li>introduce 介绍</li><li>query 查询</li><li>coach 教练</li><li>alter 改变</li><li>column 柱</li><li>method方法</li><li>文件file</li><li>领域field</li><li>regex 正则表达式</li><li>valid 有效的</li><li>module 单元、模块</li><li>title 标题、称谓</li><li>untitled 无标题的</li><li>until 直到</li><li>configured 安置、配置</li><li>kit 配套元件</li><li>SDK(Software Development Kit)</li><li>API(Application Programming Interface) 应用编程接口</li><li>appear 显得、看来</li><li>appearance 外貌、外观</li><li>plugins 插件</li><li>version 版本</li><li>advance 前进、预先的</li><li>advanced 高级的</li><li>contrast 对比</li><li>theme 主题</li><li>mouse 老鼠、鼠标</li><li>ambiguous 模棱两可的</li><li>post 邮递、投递</li><li>postman 邮局</li><li>scheme 计划、方案</li><li>block 块</li><li>template 样板</li><li>deployed 部署、调动</li><li>compiler 编译程序、汇编者</li><li>automatically 自动的、机械的</li><li>binary 二进制的</li><li>displacement 移位</li><li>fill 填满</li><li>pattern 图案</li><li>hard adj-坚固的，adv-努力地</li><li>scroll n-纸卷，v-滚动</li><li>dimension n-维，尺寸 adj-切成特定尺寸的</li><li>parse 作语法分析</li><li>judge 判断</li><li>Frame 窗体</li><li>farm 农场</li><li>expression 表示</li><li>stream n-流，v-流动</li><li>interrupt 打断</li><li>trace vt-查出，n-痕迹</li><li>dialog 对话框，对话</li><li>suspend 暂停</li><li>tempory 临时</li><li>MVC （Model-View-Controller)</li><li>organizations 社团</li><li>component 组成成分</li><li>override 推翻</li><li>current 现在的</li><li>sort 分类，排序</li><li>commons 平民、公地</li><li>stereo 立体声</li><li>podcast 博客</li><li>social 社会的</li><li>customer 顾客</li><li>address 地址</li><li>delivery 派送、分发</li><li>State 状态</li><li>query 查询</li><li>info 信息</li><li>prefer 更喜欢</li><li>validate 验证、确认</li><li>register 注册</li><li>foreground 前景、强调</li><li>check 检测</li><li>edit 编辑</li><li>preferred 首选</li><li>dimension 维，尺寸</li><li>internal 内部的</li><li>validate 验证</li><li>column 列</li><li>row 行</li><li>truncate 截断、adj.被删节的</li><li>restore 恢复</li><li>compression 压缩</li><li>canvas 帆布、油画</li><li>handler 处理器</li><li>warning 警告</li><li>native 出生地的</li><li>assets 资产</li><li>res 物、事件</li><li>blank 空白的</li><li>black 黑的</li><li>handle 把手、处理</li><li>kit 配套元件、装备</li><li>observe 看到、注意到</li><li>gap 缺口、缝隙</li><li>picture 相片、图片、想象</li><li>stroke 打一下、轻抚</li><li>round 圆形的</li><li>miter 斜接</li><li>adapter 适配器</li><li>press v按，n-记者、报刊</li><li>release 释放</li><li>instanceof 运算符，关键字</li><li>performed 做、执行、表演</li><li>internal 内部的</li><li>dispose 处置</li><li>category 类别</li><li>deploy 部署</li><li>catch 接住</li><li>Catch you late  待会见</li><li>fatal 致命的</li><li>archives 档案</li><li>categoties 类别</li><li>tags 标签</li><li>host 主办</li><li>config 配置</li><li>branch 分枝</li><li>token 代币、装样子、令牌</li><li>archive 档案文件</li><li>shrink 收缩</li><li>envelope 信封</li><li>mailto 电子邮件</li><li>sticky 粘性的、告事帖</li><li>matter 事情、要紧</li><li>copyright 版权</li><li>license 许可证、许可</li><li>common 常用的、共有的</li><li><strong>footer 页脚</strong></li><li>since 自从、因为</li><li>custon 风俗、定做</li><li>storage 存储</li><li>configure 配置</li><li>plugin 插件</li><li>prefix 前缀</li><li>fancy v.设想、n.想象的事情、adj.花哨的</li><li>ensure 确保</li><li>cooperate 合作</li><li>compatibility 兼容性</li><li>npm Node Package Manager</li><li>asset 资产</li><li>secure 保护</li><li>license 许可证</li><li>appearance 外貌</li><li>wheel 轮、推</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
          <category> 单词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 单词积累 </tag>
            
            <tag> 编程单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day02-27-移除元素</title>
      <link href="/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2022/01/18/Algorithm/Day02-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>你不需要考虑数组中超出新长度后面的元素。</p><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><ul><li>用一个for循环遍历数组，遇到相同的元素，从该位置开始，后面元素前移</li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果:  nums[j] = nums[j+1];索引越界报错，假如j为最后一个元素，是没有j+1个元素的<h2 id="改错后"><a href="#改错后" class="headerlink" title="改错后"></a>改错后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != size-<span class="number">1</span>) &#123;</span><br><span class="line">                        nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nums[j] = <span class="number">101</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果： 加了对最后一个元素的判断还是不行。仔细想了想其实是，若有目标元素size就减小了，而我for循环里用的.length。 同时元素向前移动，i的值也应减小<h2 id="再次改进"><a href="#再次改进" class="headerlink" title="再次改进"></a>再次改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int size = nums.length;</span><br><span class="line">        for(int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if(nums[i] == val) &#123;</span><br><span class="line">                for(int j = i; j &lt; size; j++) &#123;</span><br><span class="line">                    if (j != size-1) &#123;</span><br><span class="line">                        nums[j] = nums[j+1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        nums[j] = 101;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果： 正确解答! 但是内存消耗和时间复杂度都太高</li></ul><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line"></span><br><span class="line">        // 快慢指针</span><br><span class="line">        int fastIndex = 0;</span><br><span class="line">        int slowIndex;</span><br><span class="line">        for (slowIndex = 0; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            if (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slowIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是参考别人的代码，实在妙。</li><li>思想：利用两个‘指针’一前一后对数组进行遍历。若前面’指针’遇到了目标元素，则后面指针没有值，若没有遇上，就等于前面’指针’的元素。</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul><li>还是考虑不够周到</li><li>慢慢来吧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day01-7004-二分查找</title>
      <link href="/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/01/17/Algorithm/Day01-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>704.给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4    </span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1   </span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p>你可以假设 nums 中的所有元素是不重复的。</p></li><li><p>n 将在 [1, 10000]之间。</p></li><li><p>nums 的每个元素都将在 [-9999, 9999]之间。</p><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while(first &lt; last) &#123;</span><br><span class="line">            int mid = (first + last) / 2;</span><br><span class="line">            if(target &gt; nums[mid]) &#123;</span><br><span class="line">                first = first + 1;</span><br><span class="line">            &#125; else if(target &lt; nums[mid]) &#123;</span><br><span class="line">                last = last - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提示有部分测试解答错误，并且该答案只是将时间复杂度降到了O(n/2)。</p></li></ul><h2 id="第二次改进"><a href="#第二次改进" class="headerlink" title="第二次改进"></a>第二次改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次循环都使mid为最中间的数，成功的把时间复杂度降为O(log2(n)),并且测试通过</li></ul><h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><ul><li>在查看答案后发现忽略了目标数target的范围<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">     // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br><span class="line">        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>加入一个目标是范围判断可以有效避免程序做无用功。</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>还是考虑的太少，对算法不熟悉</li><li>要多练</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
