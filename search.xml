<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA复习笔记</title>
      <link href="/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/01/19/Java/JAVA%20%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-复习"><a href="#JAVA-复习" class="headerlink" title="JAVA 复习"></a>JAVA 复习</h1><h2 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h2><p>Java基础语法（包括数组等），类与对象（包括对象数组等），String类（包括split等常用方法），继承与多态，抽象类与接口，异常类，面向抽象原则与开闭原则（包括类图等），图形用户界面基础，集合框架（包括List接口及其实现类ArrayList、Map接口及其实现类HashMap），文件管理与输入输出流（包括File类、字符流、字节流、缓冲流等）以及线程</p><h2 id="二、注意地方"><a href="#二、注意地方" class="headerlink" title="二、注意地方"></a>二、注意地方</h2><h3 id="1-Integer类"><a href="#1-Integer类" class="headerlink" title="1.  Integer类"></a>1.  Integer类</h3><ul><li>integer.toBinaryString()输出二进制</li></ul><h3 id="2-Arrays类"><a href="#2-Arrays类" class="headerlink" title="2. Arrays类"></a>2. Arrays类</h3><ul><li><p>该类包含用于操作数组的各种方法（如排序和搜索）。 该类还包含一个静态工厂，可以将数组视为列表。</p></li><li><p>排序<br>public static void sort(double a[])<br> 含义：把参数a指定的double类型数组按照升序排序<br>public static void sort(double a[], int start, int end)<br> 含义：把参数a指定的double类型数组中索引start至end-1 的元素的值按照升序排序</p></li><li><p>二分法查找（要求数组已排序）<br>public static int binarySearch(double[] a, double number)<br> 含义：判断参数number指定的数是否在a指定的数组中，再返回该元素的索引，不在，返回一个负数。</p></li><li><p>复制<br>public static int[] copyOf(int[] original, int newLength)<br> 含义：把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组。<br>public static int[] copyOfRange(int[] original, int from, int to)<br> 含义：把参数original指定的数组中从索引from开始到 to-1的元素复制到一个新数组中，并返回这个新数组。</p><h3 id="3-enum"><a href="#3-enum" class="headerlink" title="3. enum"></a>3. enum</h3></li><li><p>定义<br>enum  Season {</p><p>   SPRING, SUMMER, AUTUMN, WINTER<br>}</p></li><li><p>用法<br>Season a ;<br>a.SPRING;</p><h3 id="4-pattern类"><a href="#4-pattern类" class="headerlink" title="4. pattern类"></a>4. pattern类</h3></li><li><p>正则表达式会用到<br>正则表达式的编译表示。<br>必须首先将正则表达式（指定为字符串）编译为此类的实例。 然后将所得的图案可以被用来创建一个Matcher对象可以匹配任意character sequences针对正则表达式。 执行匹配的所有状态都驻留在匹配器中，所以许多匹配者可以共享相同的模式。<br>因此，典型的调用序列<br>Pattern p = Pattern.compile(“a*b”);<br>Matcher m = p.matcher(“aaaaab”);<br>boolean b = m.matches();</p></li></ul><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><ol><li>长方形分为三块</li></ol><ul><li>类名（抽象类为斜体）</li><li>变量名</li><li>方法名</li><li>注意：public 为 + , 默认为缺省，protect为#，private为-；</li></ul><ol start="2"><li>关联 —&gt;</li><li>依赖 —-&gt;\</li><li>继承 —▷</li><li>实现接口 —-▷</li></ol><h3 id="6-JScrollPane"><a href="#6-JScrollPane" class="headerlink" title="6. JScrollPane"></a>6. JScrollPane</h3><p>提供轻量级组件的可滚动视图。 A JScrollPane管理视口，可选的垂直和水平滚动条以及可选的行和列标题视口。 您可以在How to Use Scroll Panes中找到面向任务的JScrollPane JScrollPane ， 这是Java教程中的一节。 请注意， JScrollPane不支持重量级组件。 </p><h3 id="7-Dimension"><a href="#7-Dimension" class="headerlink" title="7. Dimension"></a>7. Dimension</h3><p>Dimension类封装单个对象中组件的宽度和高度（以整数精度）。 该类与组件的某些属性相关联。 Component类和LayoutManager接口定义的几种方法返回一个Dimension对象。 </p><h3 id="3-三种布局"><a href="#3-三种布局" class="headerlink" title="3. 三种布局"></a>3. 三种布局</h3><ul><li>GridLayout-网格布局</li><li>BorderLayout-边框布局</li><li>FlowLayout-流式布局</li></ul><h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h3><h2 id="三、查缺补漏"><a href="#三、查缺补漏" class="headerlink" title="三、查缺补漏"></a>三、查缺补漏</h2><h3 id="1-移位运算"><a href="#1-移位运算" class="headerlink" title="1. 移位运算"></a>1. 移位运算</h3><ul><li>移位运算符</li></ul><p>** 二进制移位，移动一位相当于*2 || /2 **<br> &lt;&lt; （带符号左移） </p><blockquote><blockquote><p>（带符号右移） </p><blockquote><p>（无符号右移）<br> 列： D:\ideaWorkspace\review\src\displacement.java </p></blockquote></blockquote></blockquote><ul><li><strong>疑问： java输出负数二进制表现和机组不一样？</strong></li></ul><h3 id="2-数组的表示"><a href="#2-数组的表示" class="headerlink" title="2. 数组的表示"></a>2. 数组的表示</h3><ol><li>定义、</li></ol><ul><li>int a[]; // 不推荐</li><li>int [] a;</li></ul><ol start="2"><li>初始化</li></ol><ul><li>int a[] = new int[x];</li><li>int a[] = new int[]{1,2,3,4};</li><li>int a[] = {1,2,3,4}</li></ul><p>** 3. 注意：java不允许在声明数组中的方括号内指定数组长度。**</p><h3 id="3-修饰符表示范围"><a href="#3-修饰符表示范围" class="headerlink" title="3. 修饰符表示范围"></a>3. 修饰符表示范围</h3><table><thead><tr><th>修饰符</th><th>访问位置</th></tr></thead><tbody><tr><td>private</td><td>该类</td></tr><tr><td>默认</td><td>同一个包</td></tr><tr><td>protect</td><td>同一个项目</td></tr><tr><td>public</td><td>任何位置</td></tr></tbody></table><h3 id="4-抽象和接口的区别"><a href="#4-抽象和接口的区别" class="headerlink" title="4. 抽象和接口的区别"></a>4. 抽象和接口的区别</h3><ol><li>抽象</li></ol><ul><li>abstract方法没有方法体</li></ul><ol start="2"><li>接口</li></ol><ul><li>只能用public 和 空缺</li><li>默认为public 可以不写public</li></ul><p>** 接口规定类做什么，抽象类增加代码复用性**<br><em>见CSDN收藏</em></p><h3 id="5-Lambda表达式"><a href="#5-Lambda表达式" class="headerlink" title="5 . Lambda表达式"></a>5 . Lambda表达式</h3><ol><li>定义：Lambda表达式是一个匿名函数，即没有函数名的函数</li><li>表现形式：（参数/无参）-&gt; {多行语句}；</li><li>用法：一般用于匿名内部类，有单个方法。</li></ol><h3 id="6-输入输出流，缓冲流"><a href="#6-输入输出流，缓冲流" class="headerlink" title="6. 输入输出流，缓冲流"></a>6. 输入输出流，缓冲流</h3><ol><li>字符流</li></ol><ul><li>FileWriter</li><li>FileReader</li><li>注意方法：<br>fr.read() 读到末尾返回-1</li></ul><ol start="2"><li>字节流</li></ol><ul><li>FileInputStream</li><li>FileoutputStream</li></ul><ol start="3"><li>缓冲流</li></ol><ul><li>BufferedWriter</li><li>BufferedReader</li><li><em>创建的时候依赖与其他流 列： bf = new BufferedReader(fr)</em></li><li>注意的方法：<br>bw.readLine() 读一行  <em>不能写成 .read() , 为读一个字符</em>  //返回String<br>bw.newLine() 写一行行分隔符</li></ul><p>** 最后都需要关闭流（.close(）)    缓冲流要在文件流之前关闭**</p><h3 id="7-集合框架"><a href="#7-集合框架" class="headerlink" title="7. 集合框架"></a>7. 集合框架</h3><ul><li>迭代器 — 重点map</li></ul><ol><li>迭代器输出map的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; itervalue = map.values().iterator();</span><br><span class="line">while(itervalue.hasNext()) &#123;</span><br><span class="line">Sout(itervalue.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器输出map键-值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer,Student&gt;&gt; iterEntry = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterEntry.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer,Student&gt; entry =       (Map.Entry&lt;Integer,Student&gt;)iterEntry.next();  <span class="comment">//创造具体对象 类似于 new</span></span><br><span class="line">sout(iterEntry.getKey() + <span class="string">&quot;&lt;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-String-split"><a href="#8-String-split" class="headerlink" title="8. String split"></a>8. String split</h3><ul><li>将此字符串分割为给定的 regular expression的匹配。 </li><li>列：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;a-b-c-d&quot;;</span><br><span class="line">sout(s.split(-));</span><br><span class="line">结果： ab  c  d</span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title=". 正则表达式"></a>. 正则表达式</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习笔记</title>
      <link href="/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/19/Java/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA学习笔记"><a href="#JAVA学习笔记" class="headerlink" title="JAVA学习笔记"></a>JAVA学习笔记</h1><h2 id="Day01-2021-8-8"><a href="#Day01-2021-8-8" class="headerlink" title="Day01 2021/8/8"></a>Day01 2021/8/8</h2><h1 id="一、注意"><a href="#一、注意" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>布尔常量是可以输出的</li><li>null不可以输出<h1 id="二、错误总结"><a href="#二、错误总结" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>float f=13.14;<pre><code> System.out.println(&quot;f&quot;)；错误</code></pre> 应该(f);<h2 id="Day02-2021-8-9"><a href="#Day02-2021-8-9" class="headerlink" title="Day02 2021/8/9"></a>Day02 2021/8/9</h2><h1 id="一、注意-1"><a href="#一、注意-1" class="headerlink" title="一、注意"></a>一、注意</h1></li><li>类型转换可以是从小到大，强制类型转换是从大转小（不建议使用，有数据丢失）</li><li><pre><code>    System.out.println(5.2 / a);//可以得到小数</code></pre></li><li>‘0’ Asics为48 ‘0–9’连续</li><li>算术表达式中包&lt;含多个数据类型&gt;的值的时候，整个算术表达式的类型会自动提升。</li><li><pre><code> System.out.println(&quot;黑马&quot; + 6 + 66); ——黑马666 System.out.println(1 + 99 + &quot;年黑马&quot;);———100黑马 总结： 从左到右运算</code></pre></li><li>+=包含了强制类型转换—(不建议)<br> short s=10;<br> s += 20; 正确        等同于s = (short)(s + 20)<br> s = s + 20; 错误 </li><li>b = a++; a值先给b，再++。一般单独使用++；</li><li>异或^ 相同为T,不同为F</li><li>短路与|| 左边为真右边不执行<br> 短路或&amp;&amp; 左边为假右边不执行<h1 id="二、错误总结-1"><a href="#二、错误总结-1" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>c=”A”,为字符串（String),  c=’A’，为单个字符；</li></ol><h2 id="Day03-2021-8-10"><a href="#Day03-2021-8-10" class="headerlink" title="Day03 2021/8/10"></a>Day03 2021/8/10</h2><h1 id="一、注意-2"><a href="#一、注意-2" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>测试数据：选择正确数据、边界数据、错误数据。</li><li>for循环里的循环变量，出了循环不可使用。while循环里的变量，全局都可以使用。</li><li>for( ; ; )为for的死循环    ctrl+c可以结束循环</li></ol><h2 id="Day04-2021-8-11"><a href="#Day04-2021-8-11" class="headerlink" title="Day04 2021/8/11"></a>Day04 2021/8/11</h2><h1 id="一、注意-3"><a href="#一、注意-3" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>反复练习idea操作</li></ol><h1 id="二、错误总结-2"><a href="#二、错误总结-2" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>idea中一旦选定文件储存区域，不能对文件进行重命名。</li></ol><h1 id="idea里的快捷键"><a href="#idea里的快捷键" class="headerlink" title="idea里的快捷键"></a>idea里的快捷键</h1><ol><li>快速生成mian() psvm,</li><li>快速生成输出 sout</li><li>内容辅助 ctrl + Alt + space</li><li>ctrl + Alt + l 修改代码标准格式</li><li>ctrl + Alt + v 代码自动补全</li></ol><h2 id="Day05-2021-8-12"><a href="#Day05-2021-8-12" class="headerlink" title="Day05 2021/8/12"></a>Day05 2021/8/12</h2><h1 id="一、注意-4"><a href="#一、注意-4" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>方法重载</li><li>输出语句</li><li>从问题中提炼数据，从数据中寻找规律，从规律中程序化。<h1 id="二、错误总结-3"><a href="#二、错误总结-3" class="headerlink" title="二、错误总结"></a>二、错误总结</h1></li><li>该错误要一改都改，记得改了同样出现的地方。</li></ol><h2 id="Day06-2021-8-13"><a href="#Day06-2021-8-13" class="headerlink" title="Day06 2021/8/13"></a>Day06 2021/8/13</h2><h1 id="一、注意-5"><a href="#一、注意-5" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li>private 修饰成员变量</li><li>this关键字，加载变量前，解决局部变量隐藏成员变量</li><li>构造方法，在类中 public Student() {};</li><li>构造方法就相当于方法   函数；</li></ol><h1 id="二、错误总结-4"><a href="#二、错误总结-4" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>给字符串（String）赋值要加引号，单引号、双引号；</li></ol><h2 id="Day07-2021-8-14"><a href="#Day07-2021-8-14" class="headerlink" title="Day07 2021/8/14"></a>Day07 2021/8/14</h2><h1 id="一-注意"><a href="#一-注意" class="headerlink" title="一,注意"></a>一,注意</h1><h1 id="二-错误总结"><a href="#二-错误总结" class="headerlink" title="二,错误总结"></a>二,错误总结</h1><ol><li>System.out.println(“输入的数据是：” + line);    正确—-不能写成System.out.println(“输入的数据是： + line”);</li></ol><h2 id="Day08-2021-8-15"><a href="#Day08-2021-8-15" class="headerlink" title="Day08 2021/8/15"></a>Day08 2021/8/15</h2><h1 id="一、注意-6"><a href="#一、注意-6" class="headerlink" title="一、注意"></a>一、注意</h1><ol><li><code>[用==作比较：  基本类型：比较的是数据值是否相同      应用类型：比较的是地址值是否相同]</code>()</li><li><code>比较字符串用方法：.equals()    public boolen equals(Object and Obeject);    s1.equals(s2)</code></li><li>获取字符串中单个字符 .charAt();    </li><li>获取字符串的长度 .length();</li><li>String是可变的，StringBuilde是不可变的。</li><li>StringBulider中append添加数据并返回数据本身    reverse反转<br> B-&gt;S转换String s = sb.toString();<br> S-&gt;B转换StringBuilder sb = new StringBuilder(s);</li><li>ArrayList方法：<br> 删除–返回是否成功<br> array.remove(“world”);<br> 删除指定位置–返回别删除元素<br> array.remove(1);<br> //修改指定位置索引，返回被修改元素<br> System.out.println(array.set(1,”nima”));<pre><code> //返回索引处的元素 System.out.println(array.get(1));   //返回集合中元素的个数 System.out.println(array.size()); //输出集合 System.out.println(array); //添加 add</code></pre></li></ol><h1 id="二、错误总结-5"><a href="#二、错误总结-5" class="headerlink" title="二、错误总结"></a>二、错误总结</h1><ol><li>一般数组或者字符串的遍历用for()循环</li><li>定义变量必须初始化(与C语言不同)</li><li>字符串可以定义byte {97}输出字符，s.charAt(a) &gt;= 97正确</li><li>数字不带引号，字符串带引号；</li><li>一开始写不能忘记main方法！！！<h1 id="Day09-8-18"><a href="#Day09-8-18" class="headerlink" title="Day09/8/18"></a>Day09/8/18</h1></li></ol><h2 id="一-注意-1"><a href="#一-注意-1" class="headerlink" title="一.注意"></a>一.注意</h2><ol><li><p>快捷键 alt + insert    根据自己的需要进行选择。</p></li><li><h2 id="字符串比较不能用-比较！！！！用equal！！！"><a href="#字符串比较不能用-比较！！！！用equal！！！" class="headerlink" title="字符串比较不能用 == 比较！！！！用equal！！！"></a>字符串比较不能用 == 比较！！！！用equal！！！</h2></li><li><h2 id="多想！！多尝试！！把问题全面化，简单化！！一定可以！"><a href="#多想！！多尝试！！把问题全面化，简单化！！一定可以！" class="headerlink" title="多想！！多尝试！！把问题全面化，简单化！！一定可以！"></a>多想！！多尝试！！把问题全面化，简单化！！一定可以！</h2></li></ol><h2 id="二、错误总结-6"><a href="#二、错误总结-6" class="headerlink" title="二、错误总结"></a>二、错误总结</h2><ol><li>System.exit(0);   退出程序.</li><li>switch用String的好处，输入出错，程序不会报错，还可以继续运行下去，直到输入正确的选择。</li><li>输出特殊含义的方法   在sout里不能加引号。</li><li>用ArrayLiss中数据时，必学先取出对象，再调用对象的方法。</li><li>多思考！！！！！摆脱惯性思维！！！！！！</li><li>while 和 for里定义的变量外界不能用，但在外界定义，在里面赋值操作，外界同样改变！</li></ol><h1 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h1><h2 id="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"><a href="#程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！" class="headerlink" title="程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！"></a>程序没有最好，只有更好。只要你动脑筋想，无穷的巧妙方法！</h2><h2 id="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"><a href="#相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！" class="headerlink" title="相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！"></a>相同问题，方法不唯一。不同问题尽管类似，但要找到起不同，用合适的方法！</h2><h2 id="d-StudentManger-delete-update-Student-里对学号不存在的判断"><a href="#d-StudentManger-delete-update-Student-里对学号不存在的判断" class="headerlink" title="d://StudentManger    delete\update Student 里对学号不存在的判断"></a>d://StudentManger    delete\update Student 里对学号不存在的判断</h2><h2 id="从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！"><a href="#从问题根源解决：-想着修改、删除、重复学号怎么办-源头！！！控制添加方法—-让其不要输入重复！！！" class="headerlink" title="从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！"></a>从问题根源解决： 想着修改、删除、重复学号怎么办        源头！！！控制添加方法—-让其不要输入重复！！！</h2><h1 id="Day10-09-11"><a href="#Day10-09-11" class="headerlink" title="Day10/09/11"></a>Day10/09/11</h1><h2 id="一、注意-7"><a href="#一、注意-7" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>继承格式 public class  zi extends fu() {};</li><li>构造方法和成员方法：<br> 1.构造方法 构造方法作用概述 给对象的数据进行初始化 构造方法格式 方法名与类名相同 没有返回值类型,连void都没有 没有具体的返回值 构造方法注意事项 如果你不提供构造方法,系统会给出默认构造方法 如果你…<br> 2.成员方法 成员方法作用概述 表示对象所具有的功能(和行为)。 成员方法格式 有返回类型,可以为void类型,也可以是基本数据类型.</li><li>继承中变量 、方法的访问特点：<br> 先方法，再成员变量，再父类<br> 想访问成员用this,想访问父类用super</li><li>@override<br>@Override这个标签有什么用呢。。。。。。<br>其实我也是比较迷茫，查了一下，三个作用吧</li><li>可以给你当作注释用，感觉这个也不能说明什么，注释也没什么用。</li><li>可以告诉读你代码的人，这是对它父类方法的重写，其实很多代码规范没有为什么，规范就是规范，代码的可读性还是很重要的。</li><li>编译器可以给你验证@Override下面的方法名称是否是你父类中所有的，如果没有就会报错。</li><li>访问权限：public &gt; 默认 &gt; privata</li><li>类只支持单继承，不支持多继承，但支持多层继承。</li></ol><h1 id="Day11-09-12"><a href="#Day11-09-12" class="headerlink" title="Day11/09/12"></a>Day11/09/12</h1><h2 id="一、注意-8"><a href="#一、注意-8" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>java se :标准版 用于开发桌面应用</li><li>java ee: 企业版</li><li>java me: 微型</li></ol><h1 id="Day11-09-26"><a href="#Day11-09-26" class="headerlink" title="Day11/09/26"></a>Day11/09/26</h1><h2 id="一、注意-9"><a href="#一、注意-9" class="headerlink" title="一、注意"></a>一、注意</h2><ol><li>导包，文件直接创建，cmd      java d . Hello.java</li><li>修饰符 （publick) （protected)     (默认)    (private)</li><li>状态修饰符<br> final 最终，修饰成员 1. 方法，2. 成员变量，3. 类，4. 局部变量，5. 引用变量（如 final Student s = new Student;)。<ol><li>最终方法，不能被重写；</li><li>变量为常量，不能再次被赋值；</li><li>最终类，不能被继承。</li><li>数据值不能变；</li><li>地址值不能变，但是地址值里的内容可以变。</li></ol><hr> static 静态，可以修饰成员方法，成员变量。<ol><li>特点： 别类的所有对象共享；——–也是判断是否使用静态关键字的条件。</li><li>可以使用对象名调用，也可以使用类名调用。&lt;推荐类名调用&gt;</li><li>静态成员方法只能访问静态成员。</li><li>非静态都可以访问。</li><li>main通常为静态 所以，类下面的方法一般也为静态。<h1 id="Day12-2021-9-29"><a href="#Day12-2021-9-29" class="headerlink" title="Day12/2021/9/29"></a>Day12/2021/9/29</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="一、-多态中成员访问特点"><a href="#一、-多态中成员访问特点" class="headerlink" title="一、 多态中成员访问特点"></a>一、 <strong>多态中成员访问特点</strong></h3></li></ol></li><li></li></ol><p>![e043f945ba7d7bd37ad0329bbe9bc4a](C:\Users\23694\AppData\Local\Temp\WeChat Files\e043f945ba7d7bd37ad0329bbe9bc4a.png)<br>2. **多态的好处与弊端</p><p>![df065b619113d744a14b7e889e6837e](C:\Users\23694\AppData\Local\Temp\WeChat Files\df065b619113d744a14b7e889e6837e.png)</p><ol start="3"><li><p>**多态的转型<br>//多态</p><pre><code> Arimal a = new Cat(); //1.从子到父，父类引用指向子类对象、向上转型 a.eat();//2.从父到子，向下转型，父类引用转为子类对象 Cat c = (Cat)a; c.playGame(); //逆着看 </code></pre><h1 id="Day13-2021-10-06"><a href="#Day13-2021-10-06" class="headerlink" title="Day13/2021/10/06"></a>Day13/2021/10/06</h1><h2 id="抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png"><a href="#抽象类-55c0455d5b639de6d7782ba5329a00c-C-Users-23694-AppData-Local-Temp-WeChat-Files-55c0455d5b639de6d7782ba5329a00c-png" class="headerlink" title="抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)"></a>抽象类![55c0455d5b639de6d7782ba5329a00c](C:\Users\23694\AppData\Local\Temp\WeChat Files\55c0455d5b639de6d7782ba5329a00c.png)</h2><h3 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h3></li></ol><h1 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h1><ol><li>![9ddca1064128fcc4f0de5b42eb43295](C:\Users\23694\AppData\Local\Temp\WeChat Files\9ddca1064128fcc4f0de5b42eb43295.png)String 定义的变量赋值要加 ”“；</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="一、接口的特点"><a href="#一、接口的特点" class="headerlink" title="一、接口的特点"></a>一、接口的特点</h2><ol><li>用关键字Interface修饰；</li><li>类实现接口用implement</li><li>接口不能实例化<br> *可用多态方式，通过实现对象实例化，这叫接口多态。</li><li><strong>多态的形式<br> 具体类多态、抽象类多态、接口多态</strong></li><li><strong>多态的前提<br> 有继承或者实现关系； 有方法重写；有父类的（接口/类)引用指向(子/实现)类对象</strong><h2 id="二、接口的成员特点"><a href="#二、接口的成员特点" class="headerlink" title="二、接口的成员特点"></a>二、接口的成员特点</h2></li><li></li></ol><p>![8b1956872eda32d7978c71682dcc980](C:\Users\23694\AppData\Local\Temp\WeChat Files\8b1956872eda32d7978c71682dcc980.png)<br>2. 接口不可以实列化** 当有的方参数为接口时，调用的是接口的implement。测试类中也要用堕胎的方式创建接口**</p><h1 id="Day14-2021-10-24"><a href="#Day14-2021-10-24" class="headerlink" title="Day14/2021/10/24"></a>Day14/2021/10/24</h1><h1 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h1><p>*练习文件所在位置D:\ideaWorkspace-practice\src\：</p><h2 id="1-1-访问特点"><a href="#1-1-访问特点" class="headerlink" title="1. 1 访问特点"></a>1. 1 访问特点</h2><ol><li>内部类可以直接反问外部类的成员、包括私有</li><li>外部类要想访问内部类。必需创建对象</li></ol><h3 id="1-1-1分类"><a href="#1-1-1分类" class="headerlink" title="1.1.1分类"></a>1.1.1分类</h3><blockquote><blockquote><p>成员内部类<br>局部内部类</p></blockquote></blockquote><h2 id="1-2成员内部类"><a href="#1-2成员内部类" class="headerlink" title="1.2成员内部类"></a>1.2成员内部类</h2><h3 id="1-2-1成员内部类如何创建使用"><a href="#1-2-1成员内部类如何创建使用" class="headerlink" title="1.2.1成员内部类如何创建使用"></a>1.2.1成员内部类如何创建使用</h3><blockquote><blockquote><p>格式  ： 外部类名.内部类名 对象名 = 外部类对象.内部类对象<br>范列  ：        Outher.Inner i = new Outher().new Inner();</p><blockquote><p>注意：还有一种是在外部类方法中创建内部类对象，在测试类中直接调用该方法，实现成员内部类的创建和使用。</p></blockquote></blockquote></blockquote><h2 id="1-3局部内部类"><a href="#1-3局部内部类" class="headerlink" title="1.3局部内部类"></a>1.3局部内部类</h2><h3 id="1-3-1定义"><a href="#1-3-1定义" class="headerlink" title="1.3.1定义"></a>1.3.1定义</h3><blockquote><blockquote><p>在方法中定义的类。外界无法显示，需要在方法内部创建对象并使用该类，可以直接访问外部类的成员，也可以访问方法内的局部变量；</p></blockquote></blockquote><h2 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h2><p><em>局部内部类的一种特俗形式</em><br><strong>前提</strong> ： 存在一个类或者接口，这里类可以是具体类也可以是抽象类<br><strong>本质</strong> :   是一个继承了该类或者实现了该接口的子类^匿名对象^</p><h3 id="1-4-1-格式"><a href="#1-4-1-格式" class="headerlink" title="1.4.1 格式"></a>1.4.1 格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名() &#123;  </span><br><span class="line">重写方法；^说明继承了前面的类或者说实现了一个接口^</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>最后的分号不能忘</strong></p><h3 id="1-4-2-调用"><a href="#1-4-2-调用" class="headerlink" title="1.4.2 调用"></a>1.4.2 调用</h3><blockquote><blockquote><p>可以利用多态的方法赋值给类或者接口 ，对类或者接口进行方法调用。</p></blockquote></blockquote><h2 id="1-5-匿名内部类在开发中的作用"><a href="#1-5-匿名内部类在开发中的作用" class="headerlink" title="1.5 匿名内部类在开发中的作用"></a>1.5 匿名内部类在开发中的作用</h2><h3 id="1-5-1案例"><a href="#1-5-1案例" class="headerlink" title="1.5.1案例"></a>1.5.1案例</h3><p> //使用匿名内部类，可以使不用创建具体的猫对象<br>        jo.method(new Jumpping() {<br>            @Override<br>            public void jump() {<br>                System.out.println(“狗会跳”);<br>            }<br>        });</p><h3 id="一、注意-10"><a href="#一、注意-10" class="headerlink" title="一、注意"></a>一、注意</h3><ol><li><strong>通用</strong> 类里不能直接输出（sout),必须创建方法;</li><li><strong>通用</strong>所有可以实现的方法颜色都会发生改变；</li></ol><h3 id="二、错误总结-7"><a href="#二、错误总结-7" class="headerlink" title="二、错误总结"></a>二、错误总结</h3><h1 id="day15-2021-10-26"><a href="#day15-2021-10-26" class="headerlink" title="day15/2021/10/26"></a>day15/2021/10/26</h1><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h1 id="1、Math"><a href="#1、Math" class="headerlink" title="1、Math"></a>1、Math</h1><h2 id="1-1-Math类概述"><a href="#1-1-Math类概述" class="headerlink" title="1.1 Math类概述"></a>1.1 Math类概述</h2><blockquote><blockquote><p>基本数学方法</p></blockquote></blockquote><h2 id="1-2-Math类的常用方法"><a href="#1-2-Math类的常用方法" class="headerlink" title="1.2 Math类的常用方法"></a>1.2 Math类的常用方法</h2><ol><li>abs(int )——绝对值</li><li>ceil(double )——大于或等于参数的最小double值</li><li>floor(double )——小与或等于参数的最大double值</li><li>round(float )——四舍五入返回最接近参数的int</li><li>max(int )——较大值</li><li>min(int )——较小值</li><li>pow(double a, double b)——a的b次幂</li><li>random( )——返回为double的正直，[0.0,1.0)    <em>（int)random())可强转为int</em></li></ol><h1 id="2、System"><a href="#2、System" class="headerlink" title="2、System"></a>2、System</h1><h2 id="2-1-System类概述"><a href="#2-1-System类概述" class="headerlink" title="2.1 System类概述"></a>2.1 System类概述</h2><p><strong>包含几个有用的类字段和方法，它不能被实例化。</strong></p><h2 id="2-2-System类的常用方法"><a href="#2-2-System类的常用方法" class="headerlink" title="2.2 System类的常用方法"></a>2.2 System类的常用方法</h2><ol><li>exit(0)——终止当前运行的java虚拟机，非零表示异常终止</li><li>currentTimeMillis()——返回当前时间（以毫秒为单位）<br> *可以用来计算for循环耗时<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long strat = System.currentTimeMillis();</span><br><span class="line">for();</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">sout(&quot;time&quot; = strat - long);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="3、Object"><a href="#3、Object" class="headerlink" title="3、Object"></a>3、Object</h1><h2 id="3-1-Object类的概述"><a href="#3-1-Object类的概述" class="headerlink" title="3.1 Object类的概述"></a>3.1 Object类的概述</h2><p>** Class Object是类Object结构的根。 每个班都有Object作为超类。 所有对象（包括数组）都实现了这个类的方法。**</p><h3 id="3-1-1构造方法"><a href="#3-1-1构造方法" class="headerlink" title="3.1.1构造方法"></a>3.1.1构造方法</h3><p><strong>public Object();</strong></p><h2 id="3-2-Object类的常用方法"><a href="#3-2-Object类的常用方法" class="headerlink" title="3.2 Object类的常用方法"></a>3.2 Object类的常用方法</h2><ol><li>toString()——输出对象地址<em>建议所有子类都重写</em></li><li>equals()——</li></ol><h1 id="day16-2021-11-13"><a href="#day16-2021-11-13" class="headerlink" title="day16/2021/11/13"></a>day16/2021/11/13</h1><p><strong>==一些基础总结==</strong></p><h2 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h2><ol><li>JCheckBox 复选框 getText()</li><li>JComboBox 下拉列表 .getSelectedItem().toString()</li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>final abstract 不能同时出现</li><li>接口里也可以有抽象方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">public interface Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //A</span><br><span class="line"></span><br><span class="line">    public int x = 0;          //B </span><br><span class="line"></span><br><span class="line">    static int y = 0;          //C</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Cat implements Com &#123;</span><br><span class="line"></span><br><span class="line">    abstract void cry();       //D</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  abstract void cry(); </span><br><span class="line">B. public int x = 0;</span><br><span class="line">C.  static int y = 0; </span><br><span class="line">D. abstract void cry(); </span><br><span class="line">我的答案: D正确答案: D</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>抽象方法必须实现，接口不一定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ABCD注释标注的哪行代码有错误？</span><br><span class="line"></span><br><span class="line">interface Com &#123;</span><br><span class="line"></span><br><span class="line">    int MAX = 100;  //A</span><br><span class="line"></span><br><span class="line">    void f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal implements Com &#123;</span><br><span class="line"></span><br><span class="line">    int MIN ;      //B</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    public void f() &#123;  </span><br><span class="line"></span><br><span class="line">       MIN = 10;     //C</span><br><span class="line"></span><br><span class="line">       MAX = 200;    //D</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.  int MAX = 100;</span><br><span class="line">B.  int MIN ; </span><br><span class="line">C. MIN = 10; </span><br><span class="line">D. MAX = 200; </span><br><span class="line">我的答案: D正确答案: D</span><br></pre></td></tr></table></figure></li><li>接口方法只能用public 、 默认<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口中的方法也可以用private或protected修饰。</span><br><span class="line">A. 对</span><br><span class="line">B. 错</span><br><span class="line">我的答案: 错正确答案: 错</span><br></pre></td></tr></table></figure><h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2></li><li>(判断题)子类在方法重写时，不可以把父类的实例方法重写为类（static）方法，也不可以把父类的类（static）方法重写为实例方法。</li><li>子类继承父类的构造方法。<br>我的答案: 错正确答案: 错<br>答案解析：子类有子类的构造方法，父类有父类的构造方法，子类是不会继承父类的构造函数的，只是必须调用</li><li>** 继承普通父类可以方法重写，继承继承抽象类不可以。**</li></ol><p><strong>== 注 ==</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. (单选题)</span><br><span class="line">下列哪个代码（A，B，C，D）放入程序中标注的【代码】处将导致编译错误？</span><br><span class="line"></span><br><span class="line">class A &#123; </span><br><span class="line"></span><br><span class="line">   public float getNum() &#123;</span><br><span class="line"></span><br><span class="line">       return 3.0f;</span><br><span class="line"></span><br><span class="line">   &#125;     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class B extends A &#123; </span><br><span class="line"></span><br><span class="line">      【代码】</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A. public float getNum()&#123;return 4.0f;&#125; </span><br><span class="line">B.  public void getNum()&#123; &#125;   **√**</span><br><span class="line">C.  public void getNum(double d)&#123; &#125; </span><br><span class="line">D.  public double getNum(float d)&#123;return 4.0d;&#125;</span><br><span class="line"></span><br><span class="line">可以重写方法如改变（），不可以改变返回值类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="day17-2021-11-17"><a href="#day17-2021-11-17" class="headerlink" title="day17/2021/11/17"></a>day17/2021/11/17</h1><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\V{W{LYR]J}PIRL6CIA_NO33.png"></p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><h3 id="1-2-集合类结构体"><a href="#1-2-集合类结构体" class="headerlink" title="1,2 集合类结构体"></a>1,2 集合类结构体</h3><p>** 集合分为Collection和Map**<br>** Cpllection 分为list \ set  **</p><h3 id="1-3Collection"><a href="#1-3Collection" class="headerlink" title="1.3Collection"></a>1.3Collection</h3><h4 id="1-3-1创建Collection集合的对象"><a href="#1-3-1创建Collection集合的对象" class="headerlink" title="1.3.1创建Collection集合的对象"></a>1.3.1创建Collection集合的对象</h4><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul><h3 id="1-4-Collection的常用方法"><a href="#1-4-Collection的常用方法" class="headerlink" title="1.4 Collection的常用方法"></a>1.4 Collection的常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\M(]U7X8VZ3QLJGM]Z4RI%JW.png"></p><h3 id="1-5Collection遍历"><a href="#1-5Collection遍历" class="headerlink" title="1.5Collection遍历"></a>1.5Collection遍历</h3><p><strong>iterator 迭代器,集合专用遍历方式</strong><br> iterator<E> iterator(): 返回集合中元素的迭代器，通过iterator()方法得到 <strong>==        Iterator<String> it = list.iterator();==</strong></p><ul><li>依赖与集合存在</li></ul><p><strong>常用方法</strong></p><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构[9Z(}TRZWC%_UI5)C@QL~5B.png"></p><h3 id="1-6集合的使用步骤"><a href="#1-6集合的使用步骤" class="headerlink" title="1.6集合的使用步骤"></a>1.6集合的使用步骤</h3><ol><li>创建集合对象</li><li>添加元素</li><li>遍历集合（三总遍历方式）<blockquote><p>利用size（）和for循环<br>增强for循环<br>迭代器iterator</p></blockquote></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>== 如何把多个对象一起加入集合==</strong><br><strong>== hashCode==</strong></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>AlT + 7 打开一个窗口，可以看到类的所有信息</strong><br>**ctrl + alt + v 、补全代码</p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><h3 id="2-1-List集合概述和特点"><a href="#2-1-List集合概述和特点" class="headerlink" title="2.1 List集合概述和特点"></a>2.1 List集合概述和特点</h3><ul><li>概述：</li><li>有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 </li><li>与Set集合不同，列表允许重复元素</li><li>特点：</li><li>有序：存储和取出的元素顺序一致</li><li>可重复：存储的元素可重复<h3 id="2-2-List集合特有方法"><a href="#2-2-List集合特有方法" class="headerlink" title="2.2 List集合特有方法"></a>2.2 List集合特有方法</h3></li></ul><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\list特有方法.png"></p><h3 id="2-3并发修改异常"><a href="#2-3并发修改异常" class="headerlink" title="2.3并发修改异常"></a>2.3并发修改异常</h3><ul><li>ConcurrentModificationException</li><li>产生原因：</li><li>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致。</li></ul><h3 id="2-4Listlterator"><a href="#2-4Listlterator" class="headerlink" title="2.4Listlterator"></a>2.4Listlterator</h3><blockquote><p>列表迭代器</p></blockquote><ul><li><p>集合特有的迭代器</p></li><li><p>用于允许程序员沿任一方向遍历列表的列表的迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</p></li><li><p>常用方法：</p></li><li><p>next（）、hasNext()、previous（）、hasPrevious（）</p></li><li><p>addE e() ** 不会出现并发异常##</p></li></ul><h3 id="2-5-增强for循环"><a href="#2-5-增强for循环" class="headerlink" title="2.5 增强for循环"></a>2.5 增强for循环</h3><blockquote><p>简化数组和Collection集合的遍历<br>实际上为iterator迭代器</p></blockquote><ul><li>格式</li><li>for(元素类型 变量名 ：数组或集合名 ) { 变量既为该元素}</li></ul><h3 id="2-6数据结构"><a href="#2-6数据结构" class="headerlink" title="2.6数据结构"></a>2.6数据结构</h3><h3 id="2-7-常见数据结构"><a href="#2-7-常见数据结构" class="headerlink" title="2.7 常见数据结构"></a>2.7 常见数据结构</h3><h3 id="2-8-linkedList常用方法"><a href="#2-8-linkedList常用方法" class="headerlink" title="2.8 linkedList常用方法"></a>2.8 linkedList常用方法</h3><p><img src="D:\面向对象课件资料\黑马基础图片\集合体系结构\852.png"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>//调用迭代器方法 不是new一个迭代器对象，不用new<pre><code> ListIterator&lt;String&gt; lit =  list.listIterator();</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 黑马程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello!</title>
      <link href="/2022/01/19/JavaWeb/index/"/>
      <url>/2022/01/19/JavaWeb/index/</url>
      
        <content type="html"><![CDATA[<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(&quot;Hello,World!&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> dsf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javatest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程单词积累</title>
      <link href="/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/"/>
      <url>/2022/01/19/EnglishStudy/%E7%BC%96%E7%A8%8B%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="编程单词"><a href="#编程单词" class="headerlink" title="编程单词"></a>编程单词</h1><ol><li>object 对象</li><li>geometric 几何图形</li><li>circle 圆</li><li>rectangle 长方体</li><li>radius 半径</li><li>Perimeter周长</li><li>Diameter 直径</li><li>introduce 介绍</li><li>query 查询</li><li>coach 教练</li><li>alter 改变</li><li>column 柱</li><li>method方法</li><li>文件file</li><li>领域field</li><li>regex 正则表达式</li><li>valid 有效的</li><li>module 单元、模块</li><li>title 标题、称谓</li><li>untitled 无标题的</li><li>until 直到</li><li>configured 安置、配置</li><li>kit 配套元件</li><li>SDK(Software Development Kit)</li><li>API(Application Programming Interface) 应用编程接口</li><li>appear 显得、看来</li><li>appearance 外貌、外观</li><li>plugins 插件</li><li>version 版本</li><li>advance 前进、预先的</li><li>advanced 高级的</li><li>contrast 对比</li><li>theme 主题</li><li>mouse 老鼠、鼠标</li><li>ambiguous 模棱两可的</li><li>post 邮递、投递</li><li>postman 邮局</li><li>scheme 计划、方案</li><li>block 块</li><li>template 样板</li><li>deployed 部署、调动</li><li>compiler 编译程序、汇编者</li><li>automatically 自动的、机械的</li><li>binary 二进制的</li><li>displacement 移位</li><li>fill 填满</li><li>pattern 图案</li><li>hard adj-坚固的，adv-努力地</li><li>scroll n-纸卷，v-滚动</li><li>dimension n-维，尺寸 adj-切成特定尺寸的</li><li>parse 作语法分析</li><li>judge 判断</li><li>Frame 窗体</li><li>farm 农场</li><li>expression 表示</li><li>stream n-流，v-流动</li><li>interrupt 打断</li><li>trace vt-查出，n-痕迹</li><li>dialog 对话框，对话</li><li>suspend 暂停</li><li>tempory 临时</li><li>MVC （Model-View-Controller)</li><li>organizations 社团</li><li>component 组成成分</li><li>override 推翻</li><li>current 现在的</li><li>sort 分类，排序</li><li>commons 平民、公地</li><li>stereo 立体声</li><li>podcast 博客</li><li>social 社会的</li><li>customer 顾客</li><li>address 地址</li><li>delivery 派送、分发</li><li>State 状态</li><li>query 查询</li><li>info 信息</li><li>prefer 更喜欢</li><li>validate 验证、确认</li><li>register 注册</li><li>foreground 前景、强调</li><li>check 检测</li><li>edit 编辑</li><li>preferred 首选</li><li>dimension 维，尺寸</li><li>internal 内部的</li><li>validate 验证</li><li>column 列</li><li>row 行</li><li>truncate 截断、adj.被删节的</li><li>restore 恢复</li><li>compression 压缩</li><li>canvas 帆布、油画</li><li>handler 处理器</li><li>warning 警告</li><li>native 出生地的</li><li>assets 资产</li><li>res 物、事件</li><li>blank 空白的</li><li>black 黑的</li><li>handle 把手、处理</li><li>kit 配套元件、装备</li><li>observe 看到、注意到</li><li>gap 缺口、缝隙</li><li>picture 相片、图片、想象</li><li>stroke 打一下、轻抚</li><li>round 圆形的</li><li>miter 斜接</li><li>adapter 适配器</li><li>press v按，n-记者、报刊</li><li>release 释放</li><li>instanceof 运算符，关键字</li><li>performed 做、执行、表演</li><li>internal 内部的</li><li>dispose 处置</li><li>category 类别</li><li>deploy 部署</li><li>catch 接住</li><li>Catch you late  待会见</li><li>fatal 致命的</li><li>archives 档案</li><li>categoties 类别</li><li>tags 标签</li><li>host 主办</li><li>config 配置</li><li>branch 分枝</li><li>token 代币、装样子、令牌</li><li>archive 档案文件</li><li>shrink 收缩</li><li>envelope 信封</li><li>mailto 电子邮件</li><li>sticky 粘性的、告事帖</li><li>matter 事情、要紧</li><li>copyright 版权</li><li>license 许可证、许可</li><li>common 常用的、共有的</li><li><strong>footer 页脚</strong></li><li>since 自从、因为</li><li>custon 风俗、定做</li><li>storage 存储</li><li>configure 配置</li><li>plugin 插件</li><li>prefix 前缀</li><li>fancy v.设想、n.想象的事情、adj.花哨的</li><li>ensure 确保</li><li>cooperate 合作</li><li>compatibility 兼容性</li><li>npm Node Package Manager</li><li>asset 资产</li><li>secure 保护</li><li>license 许可证</li><li>appearance 外貌</li><li>wheel 轮、推</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 单词积累 </tag>
            
            <tag> 编程单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day01二分查找</title>
      <link href="/2022/01/17/Algorithm/Day01%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/01/17/Algorithm/Day01%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>704.给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4    </span><br></pre></td></tr></table></figure><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1   </span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p>你可以假设 nums 中的所有元素是不重复的。</p></li><li><p>n 将在 [1, 10000]之间。</p></li><li><p>nums 的每个元素都将在 [-9999, 9999]之间。</p><h2 id="第一想法"><a href="#第一想法" class="headerlink" title="第一想法"></a>第一想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while(first &lt; last) &#123;</span><br><span class="line">            int mid = (first + last) / 2;</span><br><span class="line">            if(target &gt; nums[mid]) &#123;</span><br><span class="line">                first = first + 1;</span><br><span class="line">            &#125; else if(target &lt; nums[mid]) &#123;</span><br><span class="line">                last = last - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提示有部分测试解答错误，并且该答案只是将时间复杂度降到了O(n/2)。</p></li></ul><h2 id="第二次改进"><a href="#第二次改进" class="headerlink" title="第二次改进"></a>第二次改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次循环都使mid为最中间的数，成功的把时间复杂度降为O(log2(n)),并且测试通过</li></ul><h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><ul><li>在查看答案后发现忽略了目标数target的范围<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">     // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br><span class="line">        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = nums.length - 1;</span><br><span class="line">        while (first &lt;= last) &#123;</span><br><span class="line">            int mid = first + (last - first)/2;</span><br><span class="line">            if (nums[mid] &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                last = mid - 1;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>加入一个目标是范围判断可以有效避免程序做无用功。</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>还是考虑的太少，对算法不熟悉</li><li>要多练</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
